<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texas Hold'em Poker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #1a2a2a, #0a1515);
            font-family: Arial, sans-serif;
            color: #fff;
            overflow-x: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90vw;
            max-width: 1000px;
            padding-bottom: 5vw;
        }
        .poker-table {
            background: radial-gradient(circle, #2a4a4a, #1a2a2a);
            border: 4px solid #d4af37;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            padding: 2vw;
            border-radius: 20%;
            width: 90vw;
            max-width: 1000px;
            height: 54vw;
            max-height: 600px;
            position: relative;
            overflow: hidden;
        }
        .community-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        .community-cards {
            display: flex;
            justify-content: center;
            gap: 1vw;
            margin-bottom: 1vw;
        }
        #start-game, #continue-playing {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 1vw 2vw;
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(45deg, #d4af37, #b8860b);
            border: none;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            transition: transform 0.3s, background 0.3s;
        }
        #start-game:hover, #continue-playing:hover {
            background: linear-gradient(45deg, #b8860b, #d4af37);
            transform: translate(-50%, -50%) scale(1.05);
        }
        #start-game.hidden, #continue-playing.hidden {
            display: none;
        }
        #game-status {
            font-size: clamp(14px, 1.8vw, 18px);
            color: #d4af37;
            margin-bottom: 0.5vw;
        }
        #winning-hand {
            font-size: clamp(12px, 1.6vw, 16px);
            color: #fff;
            margin-bottom: 0.5vw;
            padding: 0.5vw;
            border-radius: 4px;
            display: inline-block;
            transition: background 0.3s;
        }
        #winning-hand.action-waiting, #winning-hand.game-result {
            background-color: #2ecc71;
            color: #fff;
        }
        .community-info {
            font-size: clamp(12px, 1.6vw, 16px);
            color: #d4af37;
        }
        .player {
            position: absolute;
            width: 20vw;
            max-width: 200px;
            height: 15vw;
            max-height: 150px;
            text-align: center;
        }
        .player-cards {
            display: flex;
            justify-content: center;
            gap: 1vw;
            margin-bottom: 0.5vw;
            position: relative;
        }
        .player-cards.your-turn {
            outline: 4px solid #d4af37;
            border-radius: 10px;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 10px #d4af37; }
            50% { box-shadow: 0 0 20px #d4af37; }
            100% { box-shadow: 0 0 10px #d4af37; }
        }
        .folded-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(40px, 8vw, 80px);
            color: rgba(255, 0, 0, 0.8);
            font-weight: bold;
            z-index: 2;
            pointer-events: none;
        }
        .dealer-button {
            display: none;
            width: clamp(24px, 3vw, 36px);
            height: clamp(24px, 3vw, 36px);
            background: #d4af37;
            color: #000;
            border-radius: 50%;
            font-size: clamp(8px, 1.2vw, 12px);
            font-weight: bold;
            line-height: clamp(24px, 3vw, 36px);
            text-align: center;
            position: absolute;
            z-index: 10;
        }
        .blind-chip {
            display: none;
            width: clamp(60px, 8vw, 100px);
            height: clamp(16px, 2vw, 24px);
            background: #ffd700;
            color: #000;
            border-radius: 10px;
            font-size: clamp(8px, 1.2vw, 12px);
            font-weight: bold;
            line-height: clamp(16px, 2vw, 24px);
            text-align: center;
            position: absolute;
            z-index: 10;
            padding: 0 0.5vw;
            white-space: nowrap;
        }
        #player {
            bottom: 3vw;
            left: 50%;
            transform: translateX(-50%);
        }
        #player .dealer-button {
            top: 10%;
            left: -2vw;
            transform: translateY(-50%);
        }
        #player .blind-chip {
            top: 80%;
            left: -2vw;
            transform: translateY(-50%);
        }
        #player1 {
            top: 50%;
            left: 1vw;
            transform: translateY(-50%);
        }
        #player1 .dealer-button {
            top: 10%;
            right: -2vw;
            transform: translateY(-50%);
        }
        #player1 .blind-chip {
            top: 80%;
            right: -2vw;
            transform: translateY(-50%);
        }
        #player2 {
            top: 1vw;
            left: 50%;
            transform: translateX(-50%);
        }
        #player2 .dealer-button {
            top: 10%;
            left: -2vw;
            transform: translateY(-50%);
        }
        #player2 .blind-chip {
            top: 80%;
            left: -2vw;
            transform: translateY(-50%);
        }
        #player3 {
            top: 50%;
            right: 1vw;
            transform: translateY(-50%);
        }
        #player3 .dealer-button {
            top: 10%;
            left: -2vw;
            transform: translateY(-50%);
        }
        #player3 .blind-chip {
            top: 80%;
            left: -2vw;
            transform: translateY(-50%);
        }
        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5vw;
            margin-top: 0.5vw;
        }
        .action-buttons {
            display: none;
            position: absolute;
            bottom: -3.5vw;
            left: 50%;
            transform: translateX(-50%);
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5vw;
            z-index: 20;
        }
        .action-buttons.active {
            display: flex;
        }
        .action-buttons button {
            padding: 0.5vw 1vw;
            font-size: clamp(10px, 1.2vw, 12px);
            background: linear-gradient(45deg, #d4af37, #b8860b);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: 600;
            transition: transform 0.3s, background 0.3s;
        }
        .action-buttons button:hover:not(:disabled) {
            background: linear-gradient(45deg, #b8860b, #d4af37);
            transform: scale(1.05);
        }
        .action-buttons button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .best-hand {
            font-size: clamp(10px, 1.2vw, 12px);
            color: #d4af37;
        }
        .card {
            width: 6.2vw;
            max-width: 62px;
            height: 8.7vw;
            max-height: 87px;
            background: #fff;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: clamp(16px, 2vw, 20px);
            color: #000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            position: relative;
        }
        .card.red { color: #e63946; }
        .card.black { color: #000; }
        .card.back { background: linear-gradient(45deg, #d4af37, #b8860b); color: transparent; }
        .controls {
            display: flex;
            justify-content: center;
            gap: 1vw;
            flex-wrap: wrap;
            margin-top: 2vw;
        }
        button {
            padding: 1vw 2vw;
            font-size: clamp(12px, 1.4vw, 14px);
            background: linear-gradient(45deg, #d4af37, #b8860b);
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.3s, background 0.3s;
            text-transform: uppercase;
            font-weight: 600;
        }
        button:hover:not(:disabled) {
            background: linear-gradient(45deg, #b8860b, #d4af37);
            transform: scale(1.05);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #raise-amount {
            padding: 1vw;
            font-size: clamp(12px, 1.4vw, 14px);
            border-radius: 6px;
            border: 2px solid #d4af37;
            background: #0a1515;
            color: #fff;
            width: 8vw;
            max-width: 80px;
        }
        #raise-amount.invalid {
            border: 4px solid #e63946;
        }
        .log-container {
            width: 100%;
            max-width: 1000px;
            margin-top: 2vw;
        }
        .action-log {
            width: 100%;
            height: 20vw;
            max-height: 200px;
            background: rgba(0,0,0,0.2);
            padding: 1vw;
            border-radius: 8px;
            overflow-y: auto;
            position: relative;
        }
        .action-log.hidden {
            height: 3vw;
            max-height: 30px;
            padding: 0;
            overflow: hidden;
        }
        .action-log.hidden #action-text {
            display: none;
        }
        #log-toggle {
            position: absolute;
            right: 1.5vw;
            top: 50%;
            transform: translateY(-50%);
            padding: 0.5vw 1vw;
            background: linear-gradient(45deg, #d4af37, #b8860b);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: clamp(10px, 1.4vw, 12px);
        }
        @media (max-width: 768px) {
            .game-container {
                width: 95vw;
                padding: 10px;
            }
            .poker-table {
                width: 95vw;
                height: 57vw;
                padding: 1vw;
                border-radius: 50%;
            }
            .player {
                width: 25vw;
                max-width: 250px;
                height: 18vw;
                max-height: 180px;
            }
            .card {
                width: 7vw;
                height: 9.8vw;
                font-size: clamp(12px, 1.8vw, 14px);
            }
            #player {
                bottom: 4vw;
            }
            #player .dealer-button, #player .blind-chip {
                top: 5%;
                left: -3vw;
            }
            #player1 .dealer-button, #player1 .blind-chip {
                top: 5%;
                right: -3vw;
            }
            #player2 .dealer-button, #player2 .blind-chip {
                top: 5%;
                left: -3vw;
            }
            #player3 .dealer-button, #player3 .blind-chip {
                top: 5%;
                left: -3vw;
            }
        }
        @media (max-width: 480px) {
            .poker-table {
                width: 98vw;
                height: 59vw;
                border-radius: 50%;
            }
            .player {
                width: 30vw;
                max-width: 300px;
                height: 20vw;
                max-height: 200px;
            }
            .card {
                width: 8vw;
                height: 11.2vw;
                font-size: clamp(10px, 1.6vw, 14px);
            }
            .controls {
                flex-direction: column;
                align-items: center;
                gap: 0.5vw;
            }
            button, #raise-amount {
                width: 80%;
                max-width: 200px;
                padding: 2vw 4vw;
                font-size: clamp(14px, 2vw, 16px);
            }
            .action-buttons {
                bottom: -5vw;
            }
            #player .dealer-button, #player .blind-chip {
                top: 5%;
                left: -4vw;
            }
            #player1 .dealer-button, #player1 .blind-chip {
                top: 5%;
                right: -4vw;
            }
            #player2 .dealer-button, #player2 .blind-chip {
                top: 5%;
                left: -4vw;
            }
            #player3 .dealer-button, #player3 .blind-chip {
                top: 5%;
                left: -4vw;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="table-wrapper">
            <div class="poker-table">
                <div class="community-area">
                    <button id="start-game" onclick="game.startGame()" aria-label="Start a new Texas Hold'em game">Start Game</button>
                    <button id="continue-playing" class="hidden" onclick="game.newGame()" aria-label="Continue to the next hand">Continue Playing</button>
                    <div id="game-status" aria-live="polite"></div>
                    <div id="winning-hand" aria-live="polite"></div>
                    <div class="community-cards" id="community-cards"></div>
                    <div class="community-info">
                        <div id="pot" aria-label="Total pot size">Total Pot: 0</div>
                        <div id="bet-info" aria-label="Current bet amount">Current Bet: 0</div>
                        <div id="call-info" aria-label="Amount to call">To Call: 0</div>
                    </div>
                </div>
                <div class="player" id="player">
                    <div class="player-cards" id="player-cards">
                        <div class="action-buttons" id="player-actions"></div>
                    </div>
                    <div class="player-info">
                        <div>You</div>
                        <div class="chips" id="player-chips" aria-label="Your chip count">Chips: 1000</div>
                        <div class="best-hand" id="player-hand" aria-label="Your best hand">High Card -</div>
                        <div class="stats" id="player-stats" aria-label="Your win and fold statistics">Wins: 0 | Folds: 0</div>
                    </div>
                    <div class="dealer-button" id="player-dealer" aria-hidden="true">D</div>
                    <div class="blind-chip" id="player-blind" aria-hidden="true"></div>
                </div>
                <div class="player" id="player1">
                    <div class="player-cards" id="player1-cards"></div>
                    <div class="player-info">
                        <div>Player 1</div>
                        <div class="chips" id="player1-chips" aria-label="Player 1 chip count">Chips: 1000</div>
                        <div class="best-hand" id="player1-hand" aria-label="Player 1 best hand">High Card -</div>
                        <div class="stats" id="player1-stats" aria-label="Player 1 win and fold statistics">Wins: 0 | Folds: 0</div>
                    </div>
                    <div class="dealer-button" id="player1-dealer" aria-hidden="true">D</div>
                    <div class="blind-chip" id="player1-blind" aria-hidden="true"></div>
                </div>
                <div class="player" id="player2">
                    <div class="player-cards" id="player2-cards"></div>
                    <div class="player-info">
                        <div>Player 2</div>
                        <div class="chips" id="player2-chips" aria-label="Player 2 chip count">Chips: 1000</div>
                        <div class="best-hand" id="player2-hand" aria-label="Player 2 best hand">High Card -</div>
                        <div class="stats" id="player2-stats" aria-label="Player 2 win and fold statistics">Wins: 0 | Folds: 0</div>
                    </div>
                    <div class="dealer-button" id="player2-dealer" aria-hidden="true">D</div>
                    <div class="blind-chip" id="player2-blind" aria-hidden="true"></div>
                </div>
                <div class="player" id="player3">
                    <div class="player-cards" id="player3-cards"></div>
                    <div class="player-info">
                        <div>Player 3</div>
                        <div class="chips" id="player3-chips" aria-label="Player 3 chip count">Chips: 1000</div>
                        <div class="best-hand" id="player3-hand" aria-label="Player 3 best hand">High Card -</div>
                        <div class="stats" id="player3-stats" aria-label="Player 3 win and fold statistics">Wins: 0 | Folds: 0</div>
                    </div>
                    <div class="dealer-button" id="player3-dealer" aria-hidden="true">D</div>
                    <div class="blind-chip" id="player3-blind" aria-hidden="true"></div>
                </div>
            </div>
        </div>
        <div class="controls">
            <button id="fold" onclick="game.fold()" aria-label="Fold your hand" disabled>Fold</button>
            <button id="check" onclick="game.check()" aria-label="Check (pass without betting)" disabled>Check</button>
            <button id="call" onclick="game.call()" aria-label="Call the current bet" disabled>Call</button>
            <input type="number" id="raise-amount" min="50" step="50" value="100" aria-label="Amount to raise" oninput="game.validateRaiseAmount()" disabled>
            <button id="raise" onclick="game.raise()" aria-label="Raise the bet" disabled>Raise</button>
            <button id="new-game" onclick="game.newGame()" aria-label="Start a new hand" disabled>New Hand</button>
            <button id="reset-game" onclick="game.resetGame()" aria-label="Reset the game to initial state" disabled>Reset Game</button>
            <button id="pause-game" onclick="game.togglePause()" aria-label="Pause or resume the game">Pause</button>
        </div>
        <div class="log-container">
            <div class="action-log" id="action-log">
                <button id="log-toggle" onclick="game.toggleLog()" aria-label="Toggle action log visibility">Hide Log</button>
                <div id="action-text" aria-label="Action log"></div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const SUITS = ['♠', '♥', '♣', '♦'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const DECK = SUITS.flatMap(suit => RANKS.map(rank => ({ suit, rank })));
        const ALL_PLAYERS = ['player', 'player1', 'player2', 'player3'];
        const HAND_NAMES = ['High Card', 'Pair', 'Two Pair', 'Three of a Kind', 'Straight', 'Flush', 'Full House', 'Four of a Kind', 'Straight Flush'];
        const BLINDS = { small: 25, big: 50 };

        // Game logic module
        const gameLogic = {
            state: {
                deck: [...DECK],
                communityCards: [],
                pot: 0,
                currentBet: 0,
                phase: 'preflop',
                playersInRound: [...ALL_PLAYERS],
                foldedPlayers: [],
                currentTurn: 'none',
                dealer: 'player3',
                smallBlindPlayer: null,
                bigBlindPlayer: null,
                actionLog: [],
                isFirstGame: true,
                isPaused: false,
                players: ALL_PLAYERS.map(id => ({
                    id,
                    chips: 1000,
                    cards: [],
                    betThisRound: 0,
                    wins: 0,
                    folds: 0
                }))
            },
            handCache: new Map(),
            rankValues: RANKS.reduce((acc, r, i) => ({ ...acc, [r]: i }), {}),

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            },

            getPlayer(playerId) {
                return this.state.players.find(p => p.id === playerId);
            },

            getChips(playerId) {
                return this.getPlayer(playerId).chips;
            },

            setChips(playerId, amount) {
                this.getPlayer(playerId).chips = Math.max(0, amount);
            },

            getPlayerName(playerId) {
                return playerId === 'player' ? 'You' : `Player ${ALL_PLAYERS.indexOf(playerId) + 1}`;
            },

            evaluateHand(cards) {
                // Optimized hand evaluation
                const cacheKey = cards.map(c => `${c.rank}${c.suit}`).sort().join('|');
                if (this.handCache.has(cacheKey)) return this.handCache.get(cacheKey);

                // Fast hand evaluation: check high-value hands first
                const rankCount = cards.reduce((acc, c) => ({ ...acc, [c.rank]: (acc[c.rank] || 0) + 1 }), {});
                const suitCount = cards.reduce((acc, c) => ({ ...acc, [c.suit]: (acc[c.suit] || 0) + 1 }), {});
                const sortedRanks = cards.map(c => this.rankValues[c.rank]).sort((a, b) => b - a);
                const uniqueRanks = [...new Set(sortedRanks)];
                const isFlush = Object.values(suitCount).some(count => count >= 5);
                const isStraight = uniqueRanks.length >= 5 && (uniqueRanks[0] - uniqueRanks[4] === 4 || (uniqueRanks.includes(12) && uniqueRanks.slice(-4).every((v, i) => v === i)));

                let bestHand = { score: 0, high: sortedRanks[0], tiebreakers: sortedRanks.slice(1), cards };
                const four = Object.entries(rankCount).find(([_, count]) => count === 4);
                const three = Object.entries(rankCount).find(([_, count]) => count === 3);
                const pairs = Object.entries(rankCount).filter(([_, count]) => count === 2).map(([r]) => this.rankValues[r]).sort((a, b) => b - a);
                const kickers = sortedRanks.filter(r => !pairs.includes(r) && (!three || three[0] !== RANKS[r]) && (!four || four[0] !== RANKS[r])).slice(0, 5);

                if (isFlush && isStraight) bestHand = { score: 8, high: sortedRanks[0], tiebreakers: [], cards };
                else if (four) bestHand = { score: 7, high: this.rankValues[four[0]], tiebreakers: kickers, cards };
                else if (three && pairs.length) bestHand = { score: 6, high: this.rankValues[three[0]], tiebreakers: pairs, cards };
                else if (isFlush) bestHand = { score: 5, high: sortedRanks[0], tiebreakers: sortedRanks.slice(1), cards };
                else if (isStraight) bestHand = { score: 4, high: sortedRanks[0], tiebreakers: [], cards };
                else if (three) bestHand = { score: 3, high: this.rankValues[three[0]], tiebreakers: kickers, cards };
                else if (pairs.length === 2) bestHand = { score: 2, high: Math.max(...pairs), tiebreakers: [Math.min(...pairs), ...kickers], cards };
                else if (pairs.length === 1) bestHand = { score: 1, high: pairs[0], tiebreakers: kickers, cards };

                this.handCache.set(cacheKey, bestHand);
                return bestHand;
            },

            makeBet(playerId, amount, isRaise = false) {
                const player = this.getPlayer(playerId);
                const toCall = this.state.currentBet - player.betThisRound;
                let totalBet = isRaise ? amount : toCall;

                if (player.chips < totalBet) {
                    totalBet = player.chips;
                }

                if (player.chips <= 0 && !isRaise) {
                    this.state.playersInRound = this.state.playersInRound.filter(p => p !== playerId);
                    this.state.foldedPlayers.push(playerId);
                    player.folds++;
                    render.logAction(`${this.getPlayerName(playerId)} folded (insufficient chips).`);
                    return false;
                }

                player.chips -= totalBet;
                this.state.pot += totalBet;
                player.betThisRound += totalBet;
                if (isRaise) this.state.currentBet = player.betThisRound;
                render.logAction(`${this.getPlayerName(playerId)} ${isRaise ? `raised to ${this.state.currentBet}` : `called ${toCall}${totalBet < toCall ? ' (all-in)' : ''}`}.`);
                return true;
            },

            fold() {
                if (this.state.currentTurn !== 'player' || this.state.isPaused) return false;
                this.state.playersInRound = this.state.playersInRound.filter(p => p !== 'player');
                this.state.foldedPlayers.push('player');
                this.getPlayer('player').folds++;
                render.logAction('You folded.');
                this.state.currentTurn = this.getNextTurn();
                this.checkRoundEnd();
                return true;
            },

            check() {
                if (this.state.currentTurn !== 'player' || this.state.currentBet > this.getPlayer('player').betThisRound || this.state.isPaused) return false;
                render.logAction('You checked.');
                this.state.currentTurn = this.getNextTurn();
                render.updateGameDisplay();
                if (this.state.currentTurn !== 'player') setTimeout(() => ai.aiTurn(), 500);
                else this.checkRoundEnd();
                return true;
            },

            call() {
                if (this.state.currentTurn !== 'player' || this.state.isPaused) return false;
                if (this.makeBet('player', 0)) {
                    this.state.currentTurn = this.getNextTurn();
                    render.updateGameDisplay();
                    if (this.state.currentTurn !== 'player') setTimeout(() => ai.aiTurn(), 500);
                    else this.checkRoundEnd();
                    return true;
                }
                return false;
            },

            raise() {
                if (this.state.currentTurn !== 'player' || this.state.isPaused) return false;
                const raiseAmount = parseInt(document.getElementById('raise-amount').value);
                if (raiseAmount <= this.state.currentBet) return false;
                if (this.makeBet('player', raiseAmount, true)) {
                    this.state.currentTurn = this.getNextTurn();
                    render.updateGameDisplay();
                    if (this.state.currentTurn !== 'player') setTimeout(() => ai.aiTurn(), 500);
                    else this.checkRoundEnd();
                    return true;
                }
                return false;
            },

            getNextTurnFromDealer() {
                const dealerIndex = ALL_PLAYERS.indexOf(this.state.dealer);
                const nextIndex = (dealerIndex + 1) % 4;
                let turnIndex = nextIndex;
                do {
                    const candidate = ALL_PLAYERS[turnIndex];
                    if (this.state.playersInRound.includes(candidate)) return candidate;
                    turnIndex = (turnIndex + 1) % 4;
                } while (turnIndex !== nextIndex);
                return 'none';
            },

            getNextTurnFromBigBlind(bigBlindPlayer) {
                const bigBlindIndex = ALL_PLAYERS.indexOf(bigBlindPlayer);
                const nextIndex = (bigBlindIndex + 1) % 4;
                let turnIndex = nextIndex;
                do {
                    const candidate = ALL_PLAYERS[turnIndex];
                    if (this.state.playersInRound.includes(candidate)) return candidate;
                    turnIndex = (turnIndex + 1) % 4;
                } while (turnIndex !== nextIndex);
                return 'none';
            },

            getNextTurn() {
                const currentIndex = this.state.playersInRound.indexOf(this.state.currentTurn);
                const nextIndex = (currentIndex + 1) % this.state.playersInRound.length;
                return this.state.playersInRound[nextIndex] || 'none';
            },

            allBetsEqual() {
                return this.state.playersInRound.every(player => {
                    const p = this.getPlayer(player);
                    return p.betThisRound === this.state.currentBet || p.chips === 0;
                });
            },

            checkGameOver() {
                const activePlayers = this.state.players.filter(p => p.chips > 0);
                if (activePlayers.length <= 1) {
                    const winner = activePlayers[0];
                    const message = winner ? `${this.getPlayerName(winner.id)} won the game!` : 'Game ended with no winner.';
                    render.logAction(message);
                    render.disableControls();
                    return true;
                }
                return false;
            },

            checkRoundEnd() {
                if (this.checkGameOver()) return;
                if (this.state.playersInRound.length <= 1) {
                    this.state.phase = 'showdown';
                    const winner = this.state.playersInRound[0] || 'none';
                    if (winner !== 'none') {
                        const winnerName = this.getPlayerName(winner);
                        render.logAction(`${winnerName} won ${this.state.pot} by default`);
                        this.setChips(winner, this.getChips(winner) + this.state.pot);
                        this.getPlayer(winner).wins++;
                        this.state.pot = 0;
                    } else {
                        render.logAction('All players folded. Pot resets.');
                        this.state.pot = 0;
                    }
                    render.updateGameDisplay();
                } else if (this.allBetsEqual()) {
                    this.nextPhase();
                } else {
                    if (this.state.currentTurn === 'player') render.updateGameDisplay();
                    else setTimeout(() => ai.aiTurn(), 500);
                }
            },

            nextPhase() {
                const phases = {
                    preflop: () => {
                        this.state.communityCards = this.state.deck.slice(-3);
                        this.state.deck = this.state.deck.slice(0, -3);
                        this.state.phase = 'flop';
                        render.logAction(`Flop dealt: ${this.state.communityCards.map(c => `${c.rank}${c.suit}`).join(', ')}`);
                    },
                    flop: () => {
                        this.state.communityCards.push(this.state.deck.pop());
                        this.state.phase = 'turn';
                        render.logAction(`Turn dealt: ${this.state.communityCards[3].rank}${this.state.communityCards[3].suit}`);
                    },
                    turn: () => {
                        this.state.communityCards.push(this.state.deck.pop());
                        this.state.phase = 'river';
                        render.logAction(`River dealt: ${this.state.communityCards[4].rank}${this.state.communityCards[4].suit}`);
                    },
                    river: () => {
                        this.state.phase = 'showdown';
                        this.showdown();
                        return;
                    }
                };

                phases[this.state.phase]();
                if (this.state.phase !== 'showdown') {
                    this.state.currentBet = 0;
                    this.state.players.forEach(p => p.betThisRound = 0);
                    this.state.currentTurn = this.getNextTurnFromDealer();
                    this.state.playersInRound = ALL_PLAYERS.filter(p => this.getChips(p) > 0 && !this.state.foldedPlayers.includes(p));
                    render.updateGameDisplay();
                    if (this.state.currentTurn !== 'player') setTimeout(() => ai.aiTurn(), 500);
                }
            },

            showdown() {
                const allCards = this.state.players.reduce((acc, p) => ({
                    ...acc,
                    [p.id]: this.state.playersInRound.includes(p.id) ? [...p.cards, ...this.state.communityCards] : []
                }), {});
                const hands = this.state.players.reduce((acc, p) => ({
                    ...acc,
                    [p.id]: allCards[p.id].length ? this.evaluateHand(allCards[p.id]) : { score: -1, high: -1, tiebreakers: [] }
                }), {});

                const bets = this.state.players.map(p => ({
                    id: p.id,
                    bet: p.betThisRound,
                    inRound: this.state.playersInRound.includes(p.id)
                }));
                const sortedBets = [...new Set(bets.filter(b => b.inRound && b.bet > 0).map(b => b.bet))].sort((a, b) => a - b);
                const sidePots = sortedBets.map(bet => {
                    const eligible = bets.filter(b => b.bet >= bet && b.inRound).map(b => b.id);
                    const amount = eligible.reduce((sum, id) => {
                        const playerBet = this.getPlayer(id).betThisRound;
                        return sum + Math.min(bet, playerBet);
                    }, 0);
                    return { amount, eligible };
                });

                let message = '';
                sidePots.forEach(pot => {
                    if (pot.amount === 0) return;
                    const eligibleHands = pot.eligible.map(id => ({ id, ...hands[id] }));
                    const maxScore = Math.max(...eligibleHands.map(h => h.score));
                    let winners = eligibleHands.filter(h => h.score === maxScore);
                    const maxHigh = Math.max(...winners.map(w => w.high));
                    winners = winners.filter(w => w.high === maxHigh);
                    if (winners.length > 1) {
                        winners = winners.reduce((acc, curr) => {
                            if (!acc.length) return [curr];
                            const prevTiebreakers = acc[0].tiebreakers;
                            const currTiebreakers = curr.tiebreakers;
                            for (let i = 0; i < Math.min(prevTiebreakers.length, currTiebreakers.length); i++) {
                                if (currTiebreakers[i] > prevTiebreakers[i]) return [curr];
                                if (currTiebreakers[i] < prevTiebreakers[i]) return acc;
                            }
                            return [...acc, curr];
                        }, []);
                    }
                    const finalWinners = winners.map(w => w.id);
                    const potShare = Math.floor(pot.amount / finalWinners.length);

                    finalWinners.forEach(winner => {
                        const hand = hands[winner];
                        const winnerName = this.getPlayerName(winner);
                        message += `${winnerName} won ${potShare} with ${HAND_NAMES[hand.score]} ${RANKS[hand.high]}\n`;
                        this.setChips(winner, this.getChips(winner) + potShare);
                        this.getPlayer(winner).wins++;
                    });
                });

                render.logAction(message.trim());
                this.state.pot = 0;
                this.state.currentTurn = 'none';
                render.updateGameDisplay();
            }
        };

        // Rendering module
        const render = {
            DOM: {
                pot: document.getElementById('pot'),
                betInfo: document.getElementById('bet-info'),
                callInfo: document.getElementById('call-info'),
                gameStatus: document.getElementById('game-status'),
                winningHand: document.getElementById('winning-hand'),
                playerChips: document.getElementById('player-chips'),
                player1Chips: document.getElementById('player1-chips'),
                player2Chips: document.getElementById('player2-chips'),
                player3Chips: document.getElementById('player3-chips'),
                playerStats: document.getElementById('player-stats'),
                player1Stats: document.getElementById('player1-stats'),
                player2Stats: document.getElementById('player2-stats'),
                player3Stats: document.getElementById('player3-stats'),
                startButton: document.getElementById('start-game'),
                continueButton: document.getElementById('continue-playing'),
                foldButton: document.getElementById('fold'),
                checkButton: document.getElementById('check'),
                callButton: document.getElementById('call'),
                raiseButton: document.getElementById('raise'),
                raiseAmount: document.getElementById('raise-amount'),
                newGameButton: document.getElementById('new-game'),
                resetGameButton: document.getElementById('reset-game'),
                pauseButton: document.getElementById('pause-game'),
                communityCards: document.getElementById('community-cards'),
                playerCards: document.getElementById('player-cards'),
                player1Cards: document.getElementById('player1-cards'),
                player2Cards: document.getElementById('player2-cards'),
                player3Cards: document.getElementById('player3-cards'),
                playerHand: document.getElementById('player-hand'),
                player1Hand: document.getElementById('player1-hand'),
                player2Hand: document.getElementById('player2-hand'),
                player3Hand: document.getElementById('player3-hand'),
                playerActions: document.getElementById('player-actions'),
                players: ALL_PLAYERS.map(id => document.getElementById(id)),
                dealerButtons: ALL_PLAYERS.map(id => document.getElementById(`${id}-dealer`)),
                blindChips: ALL_PLAYERS.map(id => document.getElementById(`${id}-blind`)),
                actionLog: document.getElementById('action-log'),
                actionText: document.getElementById('action-text'),
                logToggle: document.getElementById('log-toggle')
            },

            renderCard(card, hidden = false) {
                const div = document.createElement('div');
                div.className = `card ${hidden ? 'back' : (card.suit === '♥' || card.suit === '♦' ? 'red' : 'black')}`;
                div.innerHTML = hidden ? '' : `${card.rank}<br>${card.suit}`;
                div.setAttribute('aria-label', hidden ? 'Hidden card' : `${card.rank} of ${card.suit}`);
                return div;
            },

            showActionButtons() {
                this.DOM.playerActions.innerHTML = '';
                const player = gameLogic.getPlayer('player');
                const toCall = gameLogic.state.currentBet - player.betThisRound;
                const canCheck = toCall === 0;
                const canCall = toCall > 0 && player.chips >= toCall;
                const canRaise = player.chips >= toCall + parseInt(this.DOM.raiseAmount.value);

                const buttons = [
                    { id: 'fold', text: 'Fold', action: () => gameLogic.fold(), disabled: false, aria: 'Fold your hand' },
                    { id: 'check', text: 'Check', action: () => gameLogic.check(), disabled: !canCheck, aria: 'Check (pass without betting)' },
                    { id: 'call', text: `Call ${toCall}`, action: () => gameLogic.call(), disabled: !canCall, aria: `Call ${toCall} chips` },
                    { id: 'raise', text: `Raise ${this.DOM.raiseAmount.value}`, action: () => gameLogic.raise(), disabled: !canRaise, aria: `Raise by ${this.DOM.raiseAmount.value} chips` }
                ];

                buttons.forEach(btn => {
                    const button = document.createElement('button');
                    button.id = `action-${btn.id}`;
                    button.textContent = btn.text;
                    button.onclick = btn.action;
                    button.disabled = btn.disabled || gameLogic.state.isPaused;
                    button.setAttribute('aria-label', btn.aria);
                    this.DOM.playerActions.appendChild(button);
                });

                this.DOM.playerActions.classList.add('active');
                if (!gameLogic.state.isPaused) this.DOM.playerActions.querySelector('button:not(:disabled)')?.focus();
            },

            hideActionButtons() {
                this.DOM.playerActions.classList.remove('active');
                this.DOM.playerActions.innerHTML = '';
            },

            updateGameDisplay() {
                if (gameLogic.state.isPaused) return;
                requestAnimationFrame(() => {
                    // Batch DOM updates
                    const updates = [];

                    // Community cards
                    this.DOM.communityCards.innerHTML = '';
                    gameLogic.state.communityCards.forEach(card => {
                        this.DOM.communityCards.appendChild(this.renderCard(card));
                    });

                    // Player cards and hands
                    const players = [
                        { div: this.DOM.playerCards, cards: gameLogic.state.players[0].cards, hidden: false, handDiv: this.DOM.playerHand, statsDiv: this.DOM.playerStats },
                        { div: this.DOM.player1Cards, cards: gameLogic.state.players[1].cards, hidden: gameLogic.state.phase !== 'showdown' && gameLogic.state.playersInRound.includes('player1'), handDiv: this.DOM.player1Hand, statsDiv: this.DOM.player1Stats },
                        { div: this.DOM.player2Cards, cards: gameLogic.state.players[2].cards, hidden: gameLogic.state.phase !== 'showdown' && gameLogic.state.playersInRound.includes('player2'), handDiv: this.DOM.player2Hand, statsDiv: this.DOM.player2Stats },
                        { div: this.DOM.player3Cards, cards: gameLogic.state.players[3].cards, hidden: gameLogic.state.phase !== 'showdown' && gameLogic.state.playersInRound.includes('player3'), handDiv: this.DOM.player3Hand, statsDiv: this.DOM.player3Stats }
                    ];

                    const allCards = gameLogic.state.players.reduce((acc, p) => ({
                        ...acc,
                        [p.id]: [...p.cards, ...gameLogic.state.communityCards]
                    }), {});
                    const hands = gameLogic.state.players.reduce((acc, p) => ({
                        ...acc,
                        [p.id]: allCards[p.id].length >= 2 ? gameLogic.evaluateHand(allCards[p.id]) : { score: 0, high: Math.max(...p.cards.map(c => gameLogic.rankValues[c.rank])), tiebreakers: [] }
                    }), {});

                    players.forEach((player, i) => {
                        const playerId = ALL_PLAYERS[i];
                        const actionButtons = player.div.querySelector('.action-buttons');
                        player.div.innerHTML = actionButtons ? actionButtons.outerHTML : '';
                        player.cards.forEach(card => player.div.appendChild(this.renderCard(card, player.hidden)));
                        player.handDiv.textContent = `${HAND_NAMES[hands[playerId].score]} ${RANKS[hands[playerId].high]}`;
                        player.statsDiv.textContent = `Wins: ${gameLogic.getPlayer(playerId).wins} | Folds: ${gameLogic.getPlayer(playerId).folds}`;
                        player.div.classList.toggle('your-turn', gameLogic.state.currentTurn === playerId && gameLogic.state.phase !== 'showdown');
                        updates.push(() => {
                            player.handDiv.setAttribute('aria-label', `${gameLogic.getPlayerName(playerId)} best hand: ${HAND_NAMES[hands[playerId].score]} ${RANKS[hands[playerId].high]}`);
                            player.statsDiv.setAttribute('aria-label', `${gameLogic.getPlayerName(playerId)} win and fold statistics: ${player.statsDiv.textContent}`);
                        });
                    });

                    // Folded overlays
                    this.DOM.players.forEach((el, i) => {
                        const playerId = ALL_PLAYERS[i];
                        const existingOverlay = el.querySelector('.folded-overlay');
                        if (gameLogic.state.foldedPlayers.includes(playerId)) {
                            if (!existingOverlay) {
                                const overlay = document.createElement('div');
                                overlay.className = 'folded-overlay';
                                overlay.textContent = 'X';
                                overlay.setAttribute('aria-hidden', 'true');
                                el.appendChild(overlay);
                            }
                        } else if (existingOverlay) {
                            el.removeChild(existingOverlay);
                        }
                    });

                    // Dealer and blind indicators
                    this.DOM.dealerButtons.forEach((btn, i) => {
                        btn.style.display = ALL_PLAYERS[i] === gameLogic.state.dealer ? 'block' : 'none';
                    });

                    // Game info
                    const toCall = gameLogic.state.currentBet - (gameLogic.getPlayer(gameLogic.state.currentTurn)?.betThisRound || 0);
                    updates.push(() => {
                        this.DOM.pot.textContent = `Total Pot: ${gameLogic.state.pot}`;
                        this.DOM.betInfo.textContent = `Current Bet: ${gameLogic.state.currentBet}`;
                        this.DOM.callInfo.textContent = `To Call: ${toCall}`;
                        this.DOM.gameStatus.textContent = `Phase: ${gameLogic.state.phase.charAt(0).toUpperCase() + gameLogic.state.phase.slice(1)}, Turn: ${gameLogic.getPlayerName(gameLogic.state.currentTurn)}`;
                        this.DOM.pot.setAttribute('aria-label', `Total pot size: ${gameLogic.state.pot}`);
                        this.DOM.betInfo.setAttribute('aria-label', `Current bet amount: ${gameLogic.state.currentBet}`);
                        this.DOM.callInfo.setAttribute('aria-label', `Amount to call: ${toCall}`);
                        this.DOM.gameStatus.setAttribute('aria-label', `Current phase: ${gameLogic.state.phase}, Current turn: ${gameLogic.getPlayerName(gameLogic.state.currentTurn)}`);
                    });

                    // Action prompt and continue button
                    if (gameLogic.state.currentTurn === 'player' && gameLogic.state.phase !== 'showdown' && !gameLogic.state.isPaused) {
                        this.showActionButtons();
                        this.DOM.winningHand.textContent = toCall > 0 ? `Your turn: Call ${toCall} or Raise` : 'Your turn: Check or Raise';
                        this.DOM.winningHand.classList.add('action-waiting');
                        this.DOM.winningHand.classList.remove('game-result');
                        this.DOM.continueButton.classList.add('hidden');
                    } else if (gameLogic.state.phase === 'showdown' || gameLogic.state.playersInRound.length <= 1) {
                        this.hideActionButtons();
                        this.disableControls();
                        this.DOM.continueButton.classList.remove('hidden');
                        this.DOM.winningHand.classList.remove('action-waiting');
                        this.DOM.winningHand.classList.add('game-result');
                    } else {
                        this.hideActionButtons();
                        this.DOM.continueButton.classList.add('hidden');
                        this.DOM.winningHand.classList.remove('action-waiting');
                        if (this.DOM.winningHand.textContent.includes('All players folded')) {
                            this.DOM.winningHand.classList.add('game-result');
                            this.DOM.continueButton.classList.remove('hidden');
                            this.disableControls();
                        }
                    }

                    // Chip counts and stats
                    gameLogic.state.players.forEach((p, i) => {
                        const chipDiv = this.DOM[`player${i === 0 ? '' : i}Chips`];
                        const statsDiv = this.DOM[`player${i === 0 ? '' : i}Stats`];
                        chipDiv.textContent = `Chips: ${p.chips}`;
                        statsDiv.textContent = `Wins: ${p.wins} | Folds: ${p.folds}`;
                        updates.push(() => {
                            chipDiv.setAttribute('aria-label', `${gameLogic.getPlayerName(p.id)} chip count: ${p.chips}`);
                            statsDiv.setAttribute('aria-label', `${gameLogic.getPlayerName(p.id)} win and fold statistics: Wins ${p.wins}, Folds ${p.folds}`);
                        });
                    });

                    // Button states
                    updates.push(() => {
                        this.DOM.foldButton.disabled = gameLogic.state.phase === 'showdown' || gameLogic.state.currentTurn !== 'player' || gameLogic.state.playersInRound.length <= 1 || gameLogic.state.isPaused;
                        this.DOM.checkButton.disabled = gameLogic.state.phase === 'showdown' || gameLogic.state.currentTurn !== 'player' || toCall > 0 || gameLogic.state.playersInRound.length <= 1 || gameLogic.state.isPaused;
                        this.DOM.callButton.disabled = gameLogic.state.phase === 'showdown' || gameLogic.state.currentTurn !== 'player' || toCall <= 0 || gameLogic.getChips('player') < toCall || gameLogic.state.playersInRound.length <= 1 || gameLogic.state.isPaused;
                        this.DOM.raiseButton.disabled = gameLogic.state.phase === 'showdown' || gameLogic.state.currentTurn !== 'player' || gameLogic.getChips('player') < toCall + parseInt(this.DOM.raiseAmount.value) || gameLogic.state.playersInRound.length <= 1 || gameLogic.state.isPaused;
                        this.DOM.raiseAmount.disabled = gameLogic.state.isPaused;
                        this.DOM.newGameButton.disabled = gameLogic.state.isPaused;
                        this.DOM.resetGameButton.disabled = gameLogic.state.isPaused;
                        this.DOM.pauseButton.textContent = gameLogic.state.isPaused ? 'Resume' : 'Pause';
                        this.DOM.pauseButton.setAttribute('aria-label', gameLogic.state.isPaused ? 'Resume the game' : 'Pause the game');
                    });

                    // Apply batched updates
                    updates.forEach(update => update());
                    this.DOM.actionText.textContent = gameLogic.state.actionLog.join('\n');
                });
            },

            validateRaiseAmount() {
                let value = parseInt(this.DOM.raiseAmount.value);
                const minRaise = Math.max(gameLogic.state.currentBet * 2, BLINDS.big);
                if (isNaN(value) || value < minRaise) value = minRaise;
                value = Math.round(value / 50) * 50;
                const toCall = gameLogic.state.currentBet - gameLogic.getPlayer('player').betThisRound;
                if (gameLogic.getChips('player') < toCall + value) {
                    this.DOM.raiseAmount.classList.add('invalid');
                    this.DOM.raiseButton.disabled = true;
                } else {
                    this.DOM.raiseAmount.classList.remove('invalid');
                    this.DOM.raiseButton.disabled = gameLogic.state.phase === 'showdown' || gameLogic.state.currentTurn !== 'player' || gameLogic.state.playersInRound.length <= 1 || gameLogic.state.isPaused;
                }
                this.DOM.raiseAmount.value = value;
                if (gameLogic.state.currentTurn === 'player') this.showActionButtons();
            },

            logAction(action) {
                const timestamp = new Date().toLocaleTimeString();
                gameLogic.state.actionLog.push(`[${timestamp}] ${action}`);
                if (gameLogic.state.actionLog.length > 50) gameLogic.state.actionLog.shift();
                this.DOM.actionText.textContent = gameLogic.state.actionLog.join('\n');
                this.DOM.winningHand.textContent = action;
            },

            disableControls() {
                this.DOM.foldButton.disabled = true;
                this.DOM.checkButton.disabled = true;
                this.DOM.callButton.disabled = true;
                this.DOM.raiseButton.disabled = true;
                this.DOM.raiseAmount.disabled = true;
                this.DOM.newGameButton.disabled = true;
                this.DOM.resetGameButton.disabled = true;
            }
        };

        // AI module
        const ai = {
            aiTurn() {
                if (gameLogic.state.phase === 'showdown' || !gameLogic.state.playersInRound.includes(gameLogic.state.currentTurn) || gameLogic.state.isPaused) {
                    gameLogic.state.currentTurn = gameLogic.getNextTurn();
                    if (gameLogic.state.playersInRound.length > 1 && gameLogic.state.currentTurn !== 'player') setTimeout(() => this.aiTurn(), 500);
                    else gameLogic.checkRoundEnd();
                    return;
                }

                const player = gameLogic.getPlayer(gameLogic.state.currentTurn);
                const toCall = gameLogic.state.currentBet - player.betThisRound;
                const handStrength = gameLogic.evaluateHand([...player.cards, ...gameLogic.state.communityCards]).score / 8;
                const position = gameLogic.state.playersInRound.indexOf(gameLogic.state.currentTurn);
                const isEarlyPosition = position < gameLogic.state.playersInRound.length / 2;
                const potOdds = toCall / (gameLogic.state.pot + toCall + 1);
                const aggressionFactor = gameLogic.state.phase === 'preflop' ? 0.7 : gameLogic.state.phase === 'flop' ? 0.8 : 0.9;

                let foldThreshold = 0.3 - (handStrength * 0.1);
                let raiseThreshold = 0.7 + (handStrength * 0.15) * aggressionFactor;
                if (isEarlyPosition) {
                    foldThreshold += 0.15;
                    raiseThreshold -= 0.1;
                }
                if (potOdds > 0.3) foldThreshold += 0.1;
                const actionProbability = Math.random();

                if (actionProbability < foldThreshold && player.chips >= toCall) {
                    gameLogic.state.playersInRound = gameLogic.state.playersInRound.filter(p => p !== gameLogic.state.currentTurn);
                    gameLogic.state.foldedPlayers.push(gameLogic.state.currentTurn);
                    player.folds++;
                    render.logAction(`${gameLogic.getPlayerName(gameLogic.state.currentTurn)} folded.`);
                } else if (actionProbability < raiseThreshold && player.chips >= toCall + BLINDS.big) {
                    const maxRaise = Math.min(player.chips - toCall, gameLogic.state.currentBet * 2 + (handStrength * 200));
                    const raiseAmount = Math.round((Math.random() * (maxRaise - BLINDS.big) + BLINDS.big) / 50) * 50;
                    if (!gameLogic.makeBet(gameLogic.state.currentTurn, raiseAmount, true)) return;
                } else if (toCall === 0) {
                    render.logAction(`${gameLogic.getPlayerName(gameLogic.state.currentTurn)} checked.`);
                } else if (player.chips >= toCall) {
                    if (!gameLogic.makeBet(gameLogic.state.currentTurn, 0)) return;
                } else {
                    gameLogic.state.playersInRound = gameLogic.state.playersInRound.filter(p => p !== gameLogic.state.currentTurn);
                    gameLogic.state.foldedPlayers.push(gameLogic.state.currentTurn);
                    player.folds++;
                    render.logAction(`${gameLogic.getPlayerName(gameLogic.state.currentTurn)} folded (insufficient chips).`);
                }

                gameLogic.state.currentTurn = gameLogic.getNextTurn();
                render.updateGameDisplay();
                if (gameLogic.state.playersInRound.length <= 1 || gameLogic.allBetsEqual()) gameLogic.checkRoundEnd();
                else if (gameLogic.state.currentTurn !== 'player') setTimeout(() => this.aiTurn(), 500);
            }
        };

        // Game controller
        const game = {
            startGame() {
                if (gameLogic.state.isPaused) return;
                gameLogic.state.isFirstGame = false;
                render.DOM.startButton.classList.add('hidden');
                render.DOM.continueButton.classList.add('hidden');
                gameLogic.state.deck = [...DECK];
                gameLogic.state.communityCards = [];
                gameLogic.state.pot = 0;
                gameLogic.state.currentBet = 0;
                gameLogic.state.phase = 'preflop';
                gameLogic.state.playersInRound = ALL_PLAYERS.filter(p => gameLogic.getChips(p) > 0);
                gameLogic.state.foldedPlayers = [];
                gameLogic.state.currentTurn = 'none';
                gameLogic.state.actionLog = [];
                gameLogic.state.players.forEach(p => {
                    p.cards = [];
                    p.betThisRound = 0;
                });
                this.dealCards();
                render.enableControls();
            },

            dealCards() {
                gameLogic.shuffle(gameLogic.state.deck);
                gameLogic.state.players.forEach(player => {
                    if (gameLogic.state.playersInRound.includes(player.id)) {
                        player.cards = [gameLogic.state.deck.pop(), gameLogic.state.deck.pop()];
                    }
                });
                this.applyBlinds();
                render.updateGameDisplay();
                if (gameLogic.state.currentTurn !== 'player') setTimeout(() => ai.aiTurn(), 500);
            },

            applyBlinds() {
                const dealerIndex = ALL_PLAYERS.indexOf(gameLogic.state.dealer);
                const smallBlindIndex = (dealerIndex + 1) % 4;
                const bigBlindIndex = (dealerIndex + 2) % 4;
                const smallBlindPlayer = ALL_PLAYERS[smallBlindIndex];
                const bigBlindPlayer = ALL_PLAYERS[bigBlindIndex];

                gameLogic.state.smallBlindPlayer = smallBlindPlayer;
                gameLogic.state.bigBlindPlayer = bigBlindPlayer;

                render.DOM.dealerButtons.forEach(el => el.style.display = 'none');
                render.DOM.blindChips.forEach(el => el.style.display = 'none');

                if (gameLogic.getChips(smallBlindPlayer) >= BLINDS.small) {
                    gameLogic.setChips(smallBlindPlayer, gameLogic.getChips(smallBlindPlayer) - BLINDS.small);
                    gameLogic.state.pot += BLINDS.small;
                    gameLogic.getPlayer(smallBlindPlayer).betThisRound = BLINDS.small;
                    render.DOM.blindChips[smallBlindIndex].innerHTML = `♠ SB ${BLINDS.small}`;
                    render.DOM.blindChips[smallBlindIndex].style.display = 'inline-block';
                    render.logAction(`${gameLogic.getPlayerName(smallBlindPlayer)} paid small blind: ${BLINDS.small}`);
                } else {
                    gameLogic.state.playersInRound = gameLogic.state.playersInRound.filter(p => p !== smallBlindPlayer);
                    gameLogic.state.foldedPlayers.push(smallBlindPlayer);
                    gameLogic.getPlayer(smallBlindPlayer).folds++;
                    render.logAction(`${gameLogic.getPlayerName(smallBlindPlayer)} folded (insufficient chips for small blind).`);
                }

                if (gameLogic.getChips(bigBlindPlayer) >= BLINDS.big) {
                    gameLogic.setChips(bigBlindPlayer, gameLogic.getChips(bigBlindPlayer) - BLINDS.big);
                    gameLogic.state.pot += BLINDS.big;
                    gameLogic.getPlayer(bigBlindPlayer).betThisRound = BLINDS.big;
                    render.DOM.blindChips[bigBlindIndex].innerHTML = `♠ BB ${BLINDS.big}`;
                    render.DOM.blindChips[bigBlindIndex].style.display = 'inline-block';
                    render.logAction(`${gameLogic.getPlayerName(bigBlindPlayer)} paid big blind: ${BLINDS.big}`);
                } else {
                    gameLogic.state.playersInRound = gameLogic.state.playersInRound.filter(p => p !== bigBlindPlayer);
                    gameLogic.state.foldedPlayers.push(bigBlindPlayer);
                    gameLogic.getPlayer(bigBlindPlayer).folds++;
                    render.logAction(`${gameLogic.getPlayerName(bigBlindPlayer)} folded (insufficient chips for big blind).`);
                }

                gameLogic.state.currentBet = BLINDS.big;
                gameLogic.state.currentTurn = gameLogic.getNextTurnFromBigBlind(bigBlindPlayer);
                if (!gameLogic.state.playersInRound.includes(gameLogic.state.currentTurn)) {
                    gameLogic.state.currentTurn = gameLogic.getNextTurn();
                }
                render.updateGameDisplay();
            },

            newGame() {
                if (gameLogic.state.isPaused) return;
                const currentDealerIndex = ALL_PLAYERS.indexOf(gameLogic.state.dealer);
                gameLogic.state.dealer = ALL_PLAYERS[(currentDealerIndex + 1) % 4];
                Object.assign(gameLogic.state, {
                    deck: [...DECK],
                    communityCards: [],
                    pot: 0,
                    currentBet: 0,
                    phase: 'preflop',
                    playersInRound: ALL_PLAYERS.filter(p => gameLogic.getChips(p) > 0),
                    foldedPlayers: [],
                    currentTurn: 'none',
                    smallBlindPlayer: null,
                    bigBlindPlayer: null,
                    actionLog: []
                });
                gameLogic.state.players.forEach(p => {
                    p.cards = [];
                    p.betThisRound = 0;
                });
                render.DOM.continueButton.classList.add('hidden');
                render.updateGameDisplay();
                render.DOM.actionText.textContent = '';
                render.DOM.winningHand.textContent = '';
                if (!gameLogic.state.isFirstGame) {
                    this.startGame();
                } else {
                    render.DOM.startButton.classList.remove('hidden');
                }
            },

            resetGame() {
                if (gameLogic.state.isPaused) return;
                Object.assign(gameLogic.state, {
                    deck: [...DECK],
                    communityCards: [],
                    pot: 0,
                    currentBet: 0,
                    phase: 'preflop',
                    playersInRound: [...ALL_PLAYERS],
                    foldedPlayers: [],
                    currentTurn: 'none',
                    dealer: 'player3',
                    smallBlindPlayer: null,
                    bigBlindPlayer: null,
                    actionLog: [],
                    isFirstGame: true,
                    isPaused: false
                });
                gameLogic.state.players.forEach(p => {
                    p.chips = 1000;
                    p.cards = [];
                    p.betThisRound = 0;
                    p.wins = 0;
                    p.folds = 0;
                });
                gameLogic.handCache.clear();
                render.DOM.continueButton.classList.add('hidden');
                render.updateGameDisplay();
                render.DOM.actionText.textContent = '';
                render.DOM.winningHand.textContent = '';
                render.DOM.startButton.classList.remove('hidden');
                render.DOM.pauseButton.textContent = 'Pause';
                render.DOM.pauseButton.setAttribute('aria-label', 'Pause the game');
            },

            togglePause() {
                gameLogic.state.isPaused = !gameLogic.state.isPaused;
                render.updateGameDisplay();
            },

            toggleLog() {
                render.DOM.actionLog.classList.toggle('hidden');
                render.DOM.logToggle.textContent = render.DOM.actionLog.classList.contains('hidden') ? 'Show Log' : 'Hide Log';
                render.DOM.logToggle.setAttribute('aria-label', render.DOM.actionLog.classList.contains('hidden') ? 'Show action log' : 'Hide action log');
            },

            validateRaiseAmount() {
                render.validateRaiseAmount();
            },

            fold() { gameLogic.fold(); },
            check() { gameLogic.check(); },
            call() { gameLogic.call(); },
            raise() { gameLogic.raise(); }
        };

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameLogic.state.isPaused && e.key !== 'p') return;
            if (e.key === 's' && !render.DOM.startButton.disabled && !render.DOM.startButton.classList.contains('hidden')) {
                game.startGame();
            } else if (e.key === 'c' && !render.DOM.continueButton.disabled && !render.DOM.continueButton.classList.contains('hidden')) {
                game.newGame();
            } else if (e.key === 'p') {
                game.togglePause();
            } else if (gameLogic.state.currentTurn !== 'player' || gameLogic.state.phase === 'showdown' || gameLogic.state.playersInRound.length <= 1) {
                return;
            } else if (e.key === 'f' && !render.DOM.foldButton.disabled) {
                game.fold();
            } else if (e.key === 'c' && !render.DOM.checkButton.disabled) {
                game.check();
            } else if (e.key === 'l' && !render.DOM.callButton.disabled) {
                game.call();
            } else if (e.key === 'r' && !render.DOM.raiseButton.disabled) {
                game.raise();
            } else if (e.key === 'n' && !render.DOM.newGameButton.disabled) {
                game.newGame();
            } else if (e.key === 'q' && !render.DOM.resetGameButton.disabled) {
                game.resetGame();
            }
        });
    </script>
</body>
</html>