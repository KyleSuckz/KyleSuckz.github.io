<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Poker Game</title>
    <style>
        :root {
            --primary-color: #d4af37;
            --secondary-color: #b8860b;
            --table-bg: radial-gradient(circle, #2a4a4a, #1a2a2a);
            --card-width: clamp(40px, 6.2vw, 62px);
            --card-height: clamp(56px, 8.7vw, 87px);
            --font-size-base: clamp(12px, 1.5vw, 14px);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #1a2a2a, #0a1515);
            font-family: Arial, sans-serif;
            color: #fff;
            overflow: hidden;
        }
        canvas { width: 90vw; max-width: 1000px; height: 54vw; max-height: 600px; }
        .game-container { width: 90vw; max-width: 1000px; position: relative; }
        .primary-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            width: 80%;
            max-width: 360px;
            margin-top: 0.5rem;
        }
        button {
            padding: 0.75rem 1.5rem;
            font-size: var(--font-size-base);
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        }
        button:hover:not(:disabled) {
            background: linear-gradient(45deg, var(--secondary-color), var(--primary-color));
            transform: scale(1.05);
        }
        button:disabled { background: #666; cursor: not-allowed; }
        #start-game, #continue-game {
            background-color: #2ecc71;
            width: 100%;
        }
        #start-game:hover:not(:disabled), #continue-game:hover:not(:disabled) { background-color: #27ae60; }
        #start-game[hidden], #continue-game[hidden] { display: none; }
        #winning-hand {
            font-size: var(--font-size-base);
            background-color: #2ecc71;
            padding: 0.6rem 1.2rem;
            border-radius: 4px;
            width: 100%;
            text-align: center;
        }
        #winning-hand.your-turn-blink { animation: blink 1s ease-in-out infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }
        .action-buttons {
            display: none;
            justify-content: center;
            gap: 0.4vw;
            width: 100%;
        }
        .action-buttons.active { display: flex; }
        #raise-amount {
            padding: 0.5rem;
            font-size: var(--font-size-base);
            border: 2px solid #fff;
            background: transparent;
            color: #fff;
            width: 100%;
            max-width: 120px;
            text-align: center;
        }
        #raise-amount.invalid { border-color: #e63946; }
        .log-container {
            width: 100%;
            max-width: 1000px;
            margin-top: 2vw;
        }
        .action-log {
            width: 100%;
            height: 20vw;
            max-height: 200px;
            background: rgba(0,0,0,0.2);
            padding: 1px;
            border-radius: 4px;
            overflow-y: auto;
            transition: height 0.5s ease;
        }
        .action-log.hidden { height: 50px; overflow: hidden; }
        .log-entry {
            margin-bottom: 5px;
            font-size: var(--font-size-base);
            color: #fff;
        }
        .log-entry.separator {
            color: var(--primary-color);
            font-weight: bold;
            text-align: center;
        }
        #log-toggle {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
        }
        .keyboard-hints {
            color: var(--primary-color);
            font-size: var(--font-size-base);
            margin-top: 20px;
        }
        .stats-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
            font-size: var(--font-size-base);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="primary-controls">
            <div id="winning-hand">Ready to start</div>
            <button id="start-game">Start Game</button>
            <button id="continue-game" hidden>Continue</button>
            <div class="action-buttons">
                <button id="fold" disabled>Fold</button>
                <button id="check-call" disabled>Check/Call</button>
                <button id="raise" disabled>Raise</button>
                <input id="raise-amount" type="number" min="0" step="25" disabled>
            </div>
            <button id="reset-game">Reset Game</button>
        </div>
        <div class="log-container">
            <div class="action-log">
                <div id="action-text"></div>
                <button id="log-toggle">Hide Log</button>
            </div>
        </div>
        <div class="keyboard-hints">
            Keyboard: S (Start), C (Continue), F (Fold), K (Check/Call), R (Raise), Q (Reset)
        </div>
        <div class="stats-panel" id="stats-panel"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const SUITS = ['♠', '♥', '♣', '♦'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const DECK = SUITS.flatMap(suit => RANKS.map(rank => ({ suit, rank })));
        const ALL_PLAYERS = ['player', 'player1', 'player2', 'player3'];
        const HAND_NAMES = ['High Card', 'Pair', 'Two Pair', 'Three of a Kind', 'Straight', 'Flush', 'Full House', 'Four of a Kind', 'Straight Flush'];
        const BLINDS = { small: 25, big: 50 };
        const MIN_RAISE = BLINDS.big * 2;

        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), wait);
            };
        };

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 1000/600, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(1000, 600);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        camera.position.set(0, 5, 8);
        camera.lookAt(0, 0, 0);

        const light = new THREE.PointLight(0xffffff, 0.8, 50);
        light.position.set(0, 5, 5);
        light.castShadow = true;
        light.shadow.mapSize.set(1024, 1024);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        const tableGeometry = new THREE.CylinderGeometry(5, 5, 0.2, 32, 1, true);
        const tableMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a4a4a,
            roughness: 0.7,
            metalness: 0.2
        });
        const table = new THREE.Mesh(tableGeometry, tableMaterial);
        table.rotation.x = Math.PI / 2;
        table.receiveShadow = true;
        scene.add(table);

        const borderGeometry = new THREE.TorusGeometry(5, 0.1, 16, 100);
        const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xd4af37 });
        const border = new THREE.Mesh(borderGeometry, borderMaterial);
        border.position.y = 0.11;
        border.rotation.x = Math.PI / 2;
        scene.add(border);

        const cardGeometry = new THREE.BoxGeometry(2.2, 3.2, 0.05);
        const cardBackMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            roughness: 0.5
        });
        const cardFaceMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const chipGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
        const chipMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700 });

        const render = {
            DOM: {},
            cardObjects: new Map(),
            chipObjects: new Map(),
            textElements: new Map(),
            lastWinnerText: '',
            actionButtonsState: { parent: null, nextSibling: null },

            initDOM() {
                this.DOM = {
                    communityCards: { x: 0, y: 0, z: 0.2 },
                    playerCards: { x: 0, y: -3, z: 0.2 },
                    player1Cards: { x: -4, y: 0, z: 0.2 },
                    player2Cards: { x: 0, y: 3, z: 0.2 },
                    player3Cards: { x: 4, y: 0, z: 0.2 },
                    playerHand: document.createElement('div'),
                    player1Hand: document.createElement('div'),
                    player2Hand: document.createElement('div'),
                    player3Hand: document.createElement('div'),
                    pot: document.createElement('div'),
                    currentBet: document.createElement('div'),
                    callInfo: document.createElement('div'),
                    gameStatus: document.createElement('div'),
                    startButton: document.getElementById('start-game'),
                    continueButton: document.getElementById('continue-game'),
                    foldButton: document.getElementById('fold'),
                    checkCallButton: document.getElementById('check-call'),
                    raiseButton: document.getElementById('raise'),
                    raiseAmount: document.getElementById('raise-amount'),
                    winningHand: document.getElementById('winning-hand'),
                    actionButtons: document.querySelector('.action-buttons'),
                    primaryControls: document.querySelector('.primary-controls'),
                    actionText: document.getElementById('action-text'),
                    actionLog: document.getElementById('action-log'),
                    logToggle: document.getElementById('log-toggle'),
                    resetGameButton: document.getElementById('reset-game'),
                    statsPanel: document.getElementById('stats-panel'),
                    dealerButtons: ALL_PLAYERS.map(id => ({ id, mesh: new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({ color: 0xd4af37 })) })),
                    blindChips: ALL_PLAYERS.map(id => ({ id, mesh: new THREE.Mesh(chipGeometry, chipMaterial) }))
                };
                this.DOM.players = ALL_PLAYERS.map(id => ({
                    id,
                    position: this.DOM[`${id}Cards`],
                    handDiv: this.DOM[`${id}Hand`]
                }));
                this.DOM.players.forEach(p => {
                    p.handDiv.style.cssText = 'position: absolute; color: #d4af37; font-size: clamp(12px, 1.5vw, 14px); display: none;';
                    document.body.appendChild(p.handDiv);
                });
                ['pot', 'currentBet', 'callInfo', 'gameStatus'].forEach(id => {
                    this.DOM[id].style.cssText = 'position: absolute; color: #d4af37; font-size: clamp(12px, 1.5vw, 14px);';
                    document.body.appendChild(this.DOM[id]);
                });
                this.DOM.dealerButtons.forEach(db => scene.add(db.mesh));
                this.DOM.blindChips.forEach(bc => scene.add(bc.mesh));
            },

            createCardMesh(card, hidden = false) {
                const mesh = new THREE.Mesh(cardGeometry, hidden ? cardBackMaterial : cardFaceMaterial);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                if (!hidden) {
                    const text = document.createElement('div');
                    text.style.cssText = `position: absolute; color: ${card.suit === '♥' || card.suit === '♦' ? '#e63946' : '#000'}; font-size: 20px; text-align: center;`;
                    text.innerHTML = `${card.rank}<br>${card.suit}`;
                    this.textElements.set(mesh.uuid, { text, card });
                    document.body.appendChild(text);
                }
                return mesh;
            },

            updateCardPositions() {
                this.cardObjects.forEach((mesh, key) => {
                    const [playerId, index] = key.split('-');
                    const pos = this.DOM[`${playerId}Cards`];
                    mesh.position.set(pos.x + (index * 2.4 - (playerId === 'community' ? 2.4 * (gameLogic.state.communityCards.length - 1) / 2 : 1.2)), pos.y, pos.z);
                    const text = this.textElements.get(mesh.uuid);
                    if (text) {
                        const vector = mesh.position.clone().project(camera);
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        text.text.style.cssText += `left: ${x}px; top: ${y}px;`;
                    }
                });
            },

            updateIndicatorPositions() {
                this.DOM.dealerButtons.forEach(db => {
                    const pos = this.DOM[`${db.id}Cards`];
                    db.mesh.position.set(pos.x, pos.y + (db.id === 'player' || db.id === 'player2' ? 3.5 : 0), pos.z + 0.5);
                    db.mesh.visible = db.id === gameLogic.state.dealer;
                });
                this.DOM.blindChips.forEach(bc => {
                    const pos = this.DOM[`${bc.id}Cards`];
                    bc.mesh.position.set(pos.x, pos.y + (bc.id === 'player' || db.id === 'player2' ? 3 : 0), pos.z + 0.3);
                    const player = gameLogic.getPlayer(bc.id);
                    bc.mesh.visible = (bc.id === gameLogic.state.smallBlindPlayer && player.totalBet > 0) || (bc.id === gameLogic.state.bigBlindPlayer && player.totalBet > 0);
                    bc.mesh.material.color.set(bc.id === gameLogic.state.smallBlindPlayer ? 0xaaaaaa : 0xffd700);
                });
            },

            updateTextPositions() {
                const toCall = gameLogic.state.currentBet - (gameLogic.getPlayer('player')?.betThisRound || 0);
                this.DOM.pot.textContent = `Total Pot: ${gameLogic.state.pot}`;
                this.DOM.currentBet.textContent = `Current Bet: ${gameLogic.state.currentBet}`;
                this.DOM.callInfo.textContent = `To Call: ${toCall}`;
                this.DOM.gameStatus.textContent = gameLogic.state.isFirstGame ? 'Ready to start' : `Phase: ${gameLogic.state.phase.charAt(0).toUpperCase() + gameLogic.state.phase.slice(1)}, Turn: ${gameLogic.getPlayerName(gameLogic.state.currentTurn)}`;
                const center = new THREE.Vector3(0, 0, 0.3).project(camera);
                const centerX = (center.x * 0.5 + 0.5) * window.innerWidth;
                const centerY = (-center.y * 0.5 + 0.5) * window.innerHeight;
                this.DOM.gameStatus.style.cssText += `left: ${centerX}px; top: ${centerY - 20}px; text-align: center;`;
                this.DOM.pot.style.cssText += `left: ${centerX}px; top: ${centerY + 20}px; text-align: center;`;
                this.DOM.currentBet.style.cssText += `left: ${centerX}px; top: ${centerY + 40}px; text-align: center;`;
                this.DOM.callInfo.style.cssText += `left: ${centerX}px; top: ${centerY + 60}px; text-align: center;`;
            },

            updateStatsPanel() {
                const player = gameLogic.getPlayer('player');
                const hand = gameLogic.evaluateHand([...player.cards, ...gameLogic.state.communityCards]);
                const handStrength = ai.evaluateHandStrength(hand);
                const toCall = gameLogic.state.currentBet - player.betThisRound;
                const potOdds = toCall > 0 ? (toCall / (gameLogic.state.pot + toCall) * 100).toFixed(1) : 0;
                const vpip = (player.wins + player.folds > 0 ? (player.wins / (player.wins + player.folds) * 100).toFixed(1) : 0);
                const pfr = (player.wins > 0 ? (player.wins / (player.wins + player.folds) * 100).toFixed(1) : 0);
                this.DOM.statsPanel.innerHTML = `
                    Hand Strength: ${(handStrength * 100).toFixed(1)}%<br>
                    Pot Odds: ${potOdds}%<br>
                    VPIP: ${vpip}%<br>
                    PFR: ${pfr}%
                `;
            },

            enableControls() {
                ['foldButton', 'checkCallButton', 'raiseButton', 'raiseAmount'].forEach(key => {
                    this.DOM[key].disabled = false;
                });
                this.validateRaiseAmount();
            },

            disableControls() {
                ['foldButton', 'checkCallButton', 'raiseButton', 'raiseAmount'].forEach(key => {
                    this.DOM[key].disabled = true;
                });
            },

            updateCommunityCards() {
                this.cardObjects.forEach((mesh, key) => {
                    if (key.startsWith('community')) {
                        scene.remove(mesh);
                        const text = this.textElements.get(mesh.uuid);
                        if (text) document.body.removeChild(text.text);
                        this.cardObjects.delete(key);
                        this.textElements.delete(mesh.uuid);
                    }
                });
                gameLogic.state.communityCards.forEach((card, i) => {
                    const mesh = this.createCardMesh(card);
                    this.cardObjects.set(`community-${i}`, mesh);
                    scene.add(mesh);
                });
            },

            updatePlayerCards() {
                this.cardObjects.forEach((mesh, key) => {
                    if (!key.startsWith('community')) {
                        scene.remove(mesh);
                        const text = this.textElements.get(mesh.uuid);
                        if (text) document.body.removeChild(text.text);
                        this.cardObjects.delete(key);
                        this.textElements.delete(mesh.uuid);
                    }
                });
                const hands = gameLogic.state.players.reduce((acc, p) => {
                    const cards = [...p.cards, ...gameLogic.state.communityCards];
                    return { ...acc, [p.id]: cards.length >= 2 ? gameLogic.evaluateHand(cards) : { score: -1, high: -1, tiebreakers: [], cards: [] } };
                }, {});
                this.DOM.players.forEach(({ id, handDiv }) => {
                    const player = gameLogic.getPlayer(id);
                    const hidden = id !== 'player' && !(gameLogic.state.phase === 'showdown' || gameLogic.getChips(id) === 0 || gameLogic.state.allInPlayers.has(id) || gameLogic.state.foldedPlayers.has(id));
                    player.cards.forEach((card, i) => {
                        const mesh = this.createCardMesh(card, hidden);
                        this.cardObjects.set(`${id}-${i}`, mesh);
                        scene.add(mesh);
                    });
                    const showHand = id === 'player' || gameLogic.state.phase === 'showdown' || gameLogic.getChips(id) === 0 || gameLogic.state.allInPlayers.has(id);
                    handDiv.textContent = showHand && hands[id].score > -1 ? gameLogic.getHandDescription(hands[id]) : '';
                    handDiv.style.display = showHand && hands[id].score > -1 ? 'block' : 'none';
                    const pos = this.DOM[`${id}Cards`];
                    const vector = new THREE.Vector3(pos.x, pos.y + (id === 'player' || id === 'player2' ? -0.5 : 0.5), pos.z + 0.4).project(camera);
                    handDiv.style.cssText += `left: ${(vector.x * 0.5 + 0.5) * window.innerWidth}px; top: ${(-vector.y * 0.5 + 0.5) * window.innerHeight}px;`;
                });
            },

            updateFoldedOverlays() {
                this.DOM.players.forEach(({ id }) => {
                    const existing = this.cardObjects.get(`${id}-folded`);
                    if (gameLogic.state.foldedPlayers.has(id) && !existing) {
                        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(4.8, 3.2), new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.8, transparent: true }));
                        mesh.position.set(this.DOM[`${id}Cards`].x, this.DOM[`${id}Cards`].y, this.DOM[`${id}Cards`].z + 0.1);
                        scene.add(mesh);
                        this.cardObjects.set(`${id}-folded`, mesh);
                        const text = document.createElement('div');
                        text.style.cssText = 'position: absolute; color: rgba(255, 0, 0, 0.8); font-size: clamp(30px, 6.4vw, 40px); text-align: center;';
                        text.textContent = 'X';
                        this.textElements.set(mesh.uuid, { text });
                        document.body.appendChild(text);
                    } else if (existing && !gameLogic.state.foldedPlayers.has(id)) {
                        scene.remove(existing);
                        const text = this.textElements.get(existing.uuid);
                        if (text) document.body.removeChild(text.text);
                        this.cardObjects.delete(`${id}-folded`);
                        this.textElements.delete(existing.uuid);
                    }
                });
            },

            updateChips() {
                this.chipObjects.forEach(mesh => scene.remove(mesh));
                this.chipObjects.clear();
                gameLogic.state.players.forEach((player, i) => {
                    const chipCount = Math.min(Math.floor(player.chips / 25), 40);
                    for (let j = 0; j < chipCount; j++) {
                        const chip = new THREE.Mesh(chipGeometry, chipMaterial);
                        const pos = this.DOM[`player${i === 0 ? '' : i}Cards`];
                        chip.position.set(pos.x + (j % 5) * 0.25 - 0.5, pos.y - (i === 0 || i === 2 ? 1.5 : -1.5), pos.z + (Math.floor(j / 5) * 0.06));
                        chip.castShadow = true;
                        scene.add(chip);
                        this.chipObjects.set(`${player.id}-chip-${j}`, chip);
                    }
                });
            },

            updateActionButtons() {
                const isPlayerTurn = gameLogic.state.currentTurn === 'player' && gameLogic.state.phase !== 'showdown' && !gameLogic.state.allInPlayers.has('player');
                const isRoundEnded = gameLogic.state.phase === 'showdown' || gameLogic.state.playersInRound.size <= 1;
                this.DOM.startButton.hidden = !gameLogic.state.isFirstGame;
                this.DOM.continueButton.hidden = !isRoundEnded;
                this.DOM.resetGameButton.disabled = isPlayerTurn;
                this.DOM.actionButtons.classList.toggle('active', this.DOM.startButton.hidden && this.DOM.continueButton.hidden && isPlayerTurn);
                if (isPlayerTurn) {
                    this.enableControls();
                    if (!this.actionButtonsState.parent) {
                        this.actionButtonsState.parent = this.DOM.actionButtons.parentNode;
                        this.actionButtonsState.nextSibling = this.DOM.actionButtons.nextSibling;
                    }
                    this.DOM.primaryControls.insertBefore(this.DOM.actionButtons, this.DOM.winningHand.nextSibling);
                } else {
                    this.disableControls();
                    if (this.actionButtonsState.parent) {
                        this.actionButtonsState.parent.insertBefore(this.DOM.actionButtons, this.actionButtonsState.nextSibling);
                        this.actionButtonsState = { parent: null, nextSibling: null };
                    }
                }
            },

            validateRaiseAmount() {
                const minRaise = Math.max(gameLogic.state.minRaise, gameLogic.state.currentBet + BLINDS.big);
                const toCall = gameLogic.state.currentBet - (gameLogic.getPlayer('player')?.betThisRound || 0);
                const maxRaise = gameLogic.getChips('player') + toCall;
                let value = Math.max(minRaise, Math.min(maxRaise, parseInt(this.DOM.raiseAmount.value) || minRaise));
                this.DOM.raiseAmount.value = Math.floor(value / 25) * 25;
                this.DOM.raiseAmount.classList.toggle('invalid', value < minRaise || value > maxRaise);
                this.DOM.raiseButton.disabled = gameLogic.state.phase === 'showdown' || gameLogic.state.currentTurn !== 'player' || value < minRaise || value > maxRaise || gameLogic.state.playersInRound.size <= 1;
            },

            logAction(action) {
                const timestamp = new Date().toLocaleTimeString();
                gameLogic.state.actionLog.unshift(`[${timestamp}]: ${action}`);
                if (gameLogic.state.actionLog.length > 200) gameLogic.state.actionLog.pop();
                if (action.includes('won') && (action.includes('chips with') || action.includes('as all others folded'))) {
                    this.lastWinnerText = action.replace(/^\[\d{2}:\d{2}:\d{2}\s*[AP]M\]: /, '');
                }
                this.renderLog();
            },

            renderLog() {
                this.DOM.actionText.innerHTML = '';
                gameLogic.state.actionLog.forEach(log => {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    if (log.includes('--- New Game Started ---') || log.includes('--- Game Reset ---')) {
                        entry.classList.add('separator');
                    }
                    entry.textContent = log;
                    this.DOM.actionText.appendChild(entry);
                });
            },

            updateGameDisplay() {
                requestAnimationFrame(() => {
                    this.updateCommunityCards();
                    this.updatePlayerCards();
                    this.updateFoldedOverlays();
                    this.updateIndicatorPositions();
                    this.updateTextPositions();
                    this.updateChips();
                    this.updateActionButtons();
                    this.updateStatsPanel();
                    this.renderLog();
                    renderer.render(scene, camera);
                });
            }
        };

        render.debouncedUpdateGameDisplay = debounce(render.updateGameDisplay.bind(render), 100);

        const gameLogic = {
            state: {
                deck: [...DECK],
                communityCards: [],
                pot: 0,
                currentBet: 0,
                minRaise: MIN_RAISE,
                phase: 'preflop',
                playersInRound: new Set(ALL_PLAYERS),
                foldedPlayers: new Set(),
                allInPlayers: new Set(),
                currentTurn: 'none',
                dealer: 'player3',
                smallBlindPlayer: null,
                bigBlindPlayer: null,
                actionLog: [],
                isFirstGame: true,
                sidePots: [],
                players: ALL_PLAYERS.map(id => ({
                    id,
                    chips: 1000,
                    cards: [],
                    betThisRound: 0,
                    totalBet: 0,
                    wins: 0,
                    folds: 0,
                    hasActed: false
                }))
            },
            handCache: new Map(),
            rankValues: new Map(RANKS.map((rank, idx) => [rank, idx])),

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            },

            ensureDeckSize(count) {
                if (this.state.deck.length < count) {
                    this.state.deck = this.shuffle([...DECK]);
                    render.logAction('Deck reshuffled.');
                }
            },

            getPlayer(id) {
                return this.state.players.find(p => p.id === id) || null;
            },

            getChips(id) {
                return this.getPlayer(id)?.chips || 0;
            },

            setChips(id, amount) {
                const player = this.getPlayer(id);
                if (player) player.chips = Math.max(0, amount);
            },

            getPlayerName(id) {
                return id === 'player' ? 'You' : `Player ${ALL_PLAYERS.indexOf(id)}`;
            },

            evaluateHand(cards) {
                const cacheKey = cards.map(c => `${c.rank}${c.suit}`).sort().join('|');
                if (this.handCache.has(cacheKey)) return this.handCache.get(cacheKey);

                const rankCount = cards.reduce((acc, c) => ({ ...acc, [c.rank]: (acc[c.rank] || 0) + 1 }), {});
                const suitCount = cards.reduce((acc, c) => ({ ...acc, [c.suit]: (acc[c.suit] || 0) + 1 }), {});
                const sortedRanks = cards.map(c => this.rankValues.get(c.rank)).sort((a, b) => b - a);
                const uniqueRanks = [...new Set(sortedRanks)];
                const isFlush = Object.values(suitCount).some(count => count >= 5);
                const isStraight = uniqueRanks.length >= 5 && (
                    uniqueRanks[0] - uniqueRanks[4] === 4 ||
                    (uniqueRanks.includes(12) && uniqueRanks.slice(-4).every((v, i) => v === i))
                );

                let bestHand = { score: 0, high: sortedRanks[0] || 0, tiebreakers: sortedRanks.slice(1), cards };
                const four = Object.entries(rankCount).find(([_, count]) => count === 4);
                const three = Object.entries(rankCount).find(([_, count]) => count === 3);
                const pairs = Object.entries(rankCount).filter(([_, count]) => count === 2).map(([r]) => this.rankValues.get(r)).sort((a, b) => b - a);

                if (isFlush && isStraight) {
                    const flushSuit = Object.keys(suitCount).find(s => suitCount[s] >= 5);
                    const flushCards = cards.filter(c => c.suit === flushSuit).sort((a, b) => this.rankValues.get(b.rank) - this.rankValues.get(a.rank));
                    const flushRanks = flushCards.map(c => this.rankValues.get(c.rank)).sort((a, b) => b - a);
                    let straightHigh = -1;
                    for (let i = 0; i <= flushRanks.length - 5; i++) {
                        if (flushRanks[i] - flushRanks[i + 4] === 4) {
                            straightHigh = flushRanks[i];
                            break;
                        }
                    }
                    if (straightHigh === -1 && flushRanks.includes(12) && flushRanks.slice(-4).every((v, i) => v === i)) {
                        straightHigh = flushRanks[flushRanks.length - 5] || 3;
                    }
                    if (straightHigh >= 0) {
                        const straightCards = flushCards.filter(c => {
                            const rankVal = this.rankValues.get(c.rank);
                            return rankVal <= straightHigh && rankVal >= straightHigh - 4;
                        }).slice(0, 5);
                        bestHand = { score: 8, high: straightHigh, tiebreakers: [], cards: straightCards };
                    }
                } else if (four) {
                    const fourCards = cards.filter(c => c.rank === four[0]).slice(0, 4);
                    const kickerCards = cards.filter(c => c.rank !== four[0]).sort((a, b) => this.rankValues.get(b.rank) - this.rankValues.get(a.rank)).slice(0, 1);
                    bestHand = { score: 7, high: this.rankValues.get(four[0]), tiebreakers: kickerCards.map(c => this.rankValues.get(c.rank)), cards: [...fourCards, ...kickerCards] };
                } else if (three && pairs.length) {
                    const threeCards = cards.filter(c => c.rank === three[0]).slice(0, 3);
                    const pairCards = cards.filter(c => c.rank === RANKS[pairs[0]]).slice(0, 2);
                    bestHand = { score: 6, high: this.rankValues.get(three[0]), tiebreakers: [pairs[0]], cards: [...threeCards, ...pairCards] };
                } else if (isFlush) {
                    const flushSuit = Object.keys(suitCount).find(s => suitCount[s] >= 5);
                    const flushCards = cards.filter(c => c.suit === flushSuit).sort((a, b) => this.rankValues.get(b.rank) - this.rankValues.get(a.rank)).slice(0, 5);
                    bestHand = { score: 5, high: this.rankValues.get(flushCards[0].rank), tiebreakers: flushCards.slice(1).map(c => this.rankValues.get(c.rank)), cards: flushCards };
                } else if (isStraight) {
                    let straightHigh = uniqueRanks[0];
                    if (uniqueRanks.includes(12) && uniqueRanks.slice(-4).every((v, i) => v === i)) {
                        straightHigh = uniqueRanks[uniqueRanks.length - 5] || 3;
                    }
                    const straightCards = cards.filter(c => {
                        const rankVal = this.rankValues.get(c.rank);
                        return rankVal <= straightHigh && rankVal >= straightHigh - 4;
                    }).slice(0, 5);
                    bestHand = { score: 4, high: straightHigh, tiebreakers: [], cards: straightCards };
                } else if (three) {
                    const threeCards = cards.filter(c => c.rank === three[0]).slice(0, 3);
                    const kickerCards = cards.filter(c => c.rank !== three[0]).sort((a, b) => this.rankValues.get(b.rank) - this.rankValues.get(a.rank)).slice(0, 2);
                    bestHand = { score: 3, high: this.rankValues.get(three[0]), tiebreakers: kickerCards.map(c => this.rankValues.get(c.rank)), cards: [...threeCards, ...kickerCards] };
                } else if (pairs.length >= 2) {
                    const pairCards = cards.filter(c => c.rank === RANKS[pairs[0]] || c.rank === RANKS[pairs[1]]).slice(0, 4);
                    const kickerCards = cards.filter(c => c.rank !== RANKS[pairs[0]] && c.rank !== RANKS[pairs[1]]).sort((a, b) => this.rankValues.get(b.rank) - this.rankValues.get(a.rank)).slice(0, 1);
                    bestHand = { score: 2, high: Math.max(...pairs), tiebreakers: [Math.min(...pairs), ...kickerCards.map(c => this.rankValues.get(c.rank))], cards: [...pairCards, ...kickerCards] };
                } else if (pairs.length === 1) {
                    const pairCards = cards.filter(c => c.rank === RANKS[pairs[0]]).slice(0, 2);
                    const kickerCards = cards.filter(c => c.rank !== RANKS[pairs[0]]).sort((a, b) => this.rankValues.get(b.rank) - this.rankValues.get(a.rank)).slice(0, 3);
                    bestHand = { score: 1, high: pairs[0], tiebreakers: kickerCards.map(c => this.rankValues.get(c.rank)), cards: [...pairCards, ...kickerCards] };
                } else {
                    const highCards = cards.sort((a, b) => this.rankValues.get(b.rank) - this.rankValues.get(a.rank)).slice(0, 5);
                    bestHand = { score: 0, high: this.rankValues.get(highCards[0]?.rank || '2'), tiebreakers: highCards.slice(1).map(c => this.rankValues.get(c.rank)), cards: highCards };
                }

                this.handCache.set(cacheKey, bestHand);
                return bestHand;
            },

            getHandDescription(hand) {
                const highCard = RANKS[hand.high] || 'Unknown';
                switch (hand.score) {
                    case 8: return `Straight Flush, ${highCard} high`;
                    case 7: return `Four of a Kind, ${highCard}s`;
                    case 6: return `Full House, ${highCard}s over ${RANKS[hand.tiebreakers[0]] || 'Unknown'}s`;
                    case 5: return `Flush, ${highCard} high`;
                    case 4: return `Straight, ${highCard} high`;
                    case 3: return `Three of a Kind, ${highCard}s`;
                    case 2: return `Two Pair, ${highCard}s and ${RANKS[hand.tiebreakers[0]] || 'Unknown'}s`;
                    case 1: return `Pair of ${highCard}s`;
                    default: return `High Card ${highCard}`;
                }
            },

            getPlayerOptions(id) {
                const player = this.getPlayer(id);
                if (!player || this.state.allInPlayers.has(id)) return `${this.getPlayerName(id)}: None${this.state.allInPlayers.has(id) ? ' (all-in)' : ''}`;
                const toCall = this.state.currentBet - player.betThisRound;
                const minRaise = Math.max(this.state.minRaise, this.state.currentBet + BLINDS.big);
                const options = ['Fold'];
                if (toCall === 0) options.push('Check');
                else if (player.chips >= toCall) options.push(`Call ${toCall}`);
                if (player.chips >= minRaise) options.push('Raise');
                return `${this.getPlayerName(id)}: ${options.join(', ')}`;
            },

            logChipCounts() {
                render.logAction(`Chips: ${this.state.players.map(p => `${this.getPlayerName(p.id)}: ${p.chips}`).join(', ')}`);
            },

            verifyChipTotal() {
                const totalChips = this.state.players.reduce((sum, p) => sum + p.chips, 0) + this.state.pot;
                console.log(`Total chips: ${totalChips}, Pot: ${this.state.pot}, Players: ${this.state.players.map(p => `${p.id}:${p.chips}`).join(', ')}`);
                return totalChips === 4000;
            },

            makeBet(id, amount, isRaise = false, isBlind = false) {
                const player = this.getPlayer(id);
                if (!player || player.chips <= 0 || this.state.foldedPlayers.has(id)) {
                    if (!isBlind) {
                        this.state.playersInRound.delete(id);
                        this.state.foldedPlayers.add(id);
                        player.folds++;
                        render.logAction(`${this.getPlayerName(id)} folded (no chips).`);
                    }
                    return false;
                }

                const toCall = isBlind ? 0 : Math.max(0, this.state.currentBet - player.betThisRound);
                const totalBet = isBlind ? Math.min(amount, player.chips) : isRaise ? Math.min(amount, player.chips) : Math.min(toCall, player.chips);

                if (totalBet === player.chips && !this.state.allInPlayers.has(id)) {
                    this.state.allInPlayers.add(id);
                    render.logAction(`${this.getPlayerName(id)} is all-in with ${totalBet} chips.`);
                }

                player.chips -= totalBet;
                player.betThisRound += totalBet;
                player.totalBet += totalBet;
                this.state.pot += totalBet;

                console.log(`makeBet: ${this.getPlayerName(id)} bet ${totalBet}, pot=${this.state.pot}, chips=${player.chips}`);

                if (isBlind) {
                    render.logAction(`${this.getPlayerName(id)} posted ${isRaise ? 'big blind' : 'small blind'}: ${totalBet}`);
                } else if (totalBet > 0 && !isRaise) {
                    render.logAction(`${this.getPlayerName(id)} called ${toCall}${totalBet < toCall ? ' (all-in)' : ''}`);
                }

                if (isRaise && !isBlind) {
                    this.state.currentBet = player.betThisRound;
                    this.state.minRaise = Math.max(this.state.minRaise, totalBet + BLINDS.big);
                    this.state.playersInRound.forEach(p => {
                        if (p !== id && !this.state.allInPlayers.has(p) && !this.state.foldedPlayers.has(p)) {
                            this.getPlayer(p).hasActed = false;
                        }
                    });
                }

                player.hasActed = !isBlind;
                return true;
            },

            createSidePots() {
                this.state.sidePots = [];
                const bets = this.state.players
                    .filter(p => p.totalBet > 0 && !this.state.foldedPlayers.has(p.id) && (this.state.playersInRound.has(p.id) || this.state.allInPlayers.has(p.id)))
                    .map(p => ({ id: p.id, bet: p.totalBet }))
                    .sort((a, b) => a.bet - b.bet);
                let previousBet = 0;

                bets.forEach(({ id, bet }) => {
                    if (bet > previousBet) {
                        const potAmount = (bet - previousBet) * this.state.players
                            .filter(p => p.totalBet >= bet && !this.state.foldedPlayers.has(p.id) && (this.state.playersInRound.has(p.id) || this.state.allInPlayers.has(p.id)))
                            .length;
                        if (potAmount > 0) {
                            this.state.sidePots.push({
                                amount: potAmount,
                                eligiblePlayers: this.state.players
                                    .filter(p => p.totalBet >= bet && !this.state.foldedPlayers.has(p.id) && (this.state.playersInRound.has(p.id) || this.state.allInPlayers.has(p.id)))
                                    .map(p => p.id)
                            });
                        }
                        previousBet = bet;
                    }
                });
                this.state.pot = this.state.sidePots.reduce((sum, pot) => sum + pot.amount, 0);
                console.log(`Side pots created: ${JSON.stringify(this.state.sidePots)}`);
            },

            fold() {
                if (this.state.currentTurn !== 'player') return false;
                this.state.playersInRound.delete('player');
                this.state.foldedPlayers.add('player');
                this.getPlayer('player').folds++;
                render.logAction('You folded.');
                this.state.currentTurn = this.getNextTurn();
                this.checkRound();
                return true;
            },

            checkOrCall() {
                if (this.state.currentTurn !== 'player' || this.state.allInPlayers.has('player')) return false;
                const toCall = this.state.currentBet - this.getPlayer('player').betThisRound;
                if (this.makeBet('player', toCall)) {
                    this.state.currentTurn = this.getNextTurn();
                    render.debouncedUpdateGameDisplay();
                    this.checkRound();
                    return true;
                }
                return false;
            },

            raise() {
                if (this.state.currentTurn !== 'player' || this.state.allInPlayers.has('player')) return false;
                const raiseAmount = parseInt(render.DOM.raiseAmount.value) || 0;
                if (isNaN(raiseAmount) || raiseAmount < this.state.minRaise || raiseAmount <= this.state.currentBet) return false;
                if (this.makeBet('player', raiseAmount, true)) {
                    render.logAction(`You raised to ${raiseAmount}.`);
                    this.state.currentTurn = this.getNextTurn();
                    render.debouncedUpdateGameDisplay();
                    this.checkRound();
                    return true;
                }
                return false;
            },

            getNextTurnFromDealer() {
                const dealerIndex = ALL_PLAYERS.indexOf(this.state.dealer);
                const startIndex = (dealerIndex + 1) % 4;
                for (let i = 0; i < 4; i++) {
                    const nextIndex = (startIndex + i) % 4;
                    const candidate = ALL_PLAYERS[nextIndex];
                    if (
                        this.state.playersInRound.has(candidate) &&
                        !this.state.allInPlayers.has(candidate) &&
                        !this.state.foldedPlayers.has(candidate) &&
                        (!this.getPlayer(candidate).hasActed || this.state.currentBet > this.getPlayer(candidate).betThisRound)
                    ) {
                        return candidate;
                    }
                }
                return 'none';
            },

            getNextTurnFromBigBlind(bigBlindPlayer) {
                const bigBlindIndex = ALL_PLAYERS.indexOf(bigBlindPlayer);
                const startIndex = (bigBlindIndex + 1) % 4;
                for (let i = 0; i < 4; i++) {
                    const nextIndex = (startIndex + i) % 4;
                    const candidate = ALL_PLAYERS[nextIndex];
                    if (
                        this.state.playersInRound.has(candidate) &&
                        !this.state.allInPlayers.has(candidate) &&
                        !this.state.foldedPlayers.has(candidate) &&
                        (!this.getPlayer(candidate).hasActed || this.state.currentBet > this.getPlayer(candidate).betThisRound)
                    ) {
                        return candidate;
                    }
                }
                return 'none';
            },

            getNextTurn() {
                if (![...this.state.playersInRound].every(p => this.state.allInPlayers.has(p) || this.state.foldedPlayers.has(p))) {
                    const currentIndex = this.state.currentTurn === 'none' ? -1 : ALL_PLAYERS.indexOf(this.state.currentTurn);
                    for (let i = 1; i <= 4; i++) {
                        const nextIndex = (currentIndex + i) % 4;
                        const candidate = ALL_PLAYERS[nextIndex];
                        if (
                            this.state.playersInRound.has(candidate) &&
                            !this.state.allInPlayers.has(candidate) &&
                            !this.state.foldedPlayers.has(candidate) &&
                            (!this.getPlayer(candidate).hasActed || this.state.currentBet > this.getPlayer(candidate).betThisRound)
                        ) {
                            return candidate;
                        }
                    }
                }
                return 'none';
            },

            allBetsEqual() {
                return this.state.players.every(p =>
                    p.betThisRound === this.state.currentBet ||
                    this.state.allInPlayers.has(p.id) ||
                    p.chips === 0 ||
                    this.state.foldedPlayers.has(p.id)
                );
            },

            checkGameOver() {
                const activePlayers = this.state.players.filter(p => p.chips > 0 || (this.state.allInPlayers.has(p.id) && p.totalBet > 0));
                if (activePlayers.length <= 1) {
                    const winner = activePlayers[0];
                    if (winner) {
                        render.logAction(`${this.getPlayerName(winner.id)} won with ${winner.chips} chips!`);
                        this.state.isFirstGame = true;
                        this.state.phase = 'preflop';
                        this.state.currentTurn = 'none';
                        render.debouncedUpdateGameDisplay();
                    }
                    return true;
                }
                return false;
            },

            checkRound() {
                if (this.state.playersInRound.size <= 1) {
                    this.createSidePots();
                    const winner = [...this.state.playersInRound][0];
                    if (winner) {
                        const winnerPlayer = this.getPlayer(winner);
                        winnerPlayer.chips += this.state.pot;
                        winnerPlayer.wins++;
                        render.logAction(`${this.getPlayerName(winner)} won ${this.state.pot} chips as all others folded.`);
                        this.state.pot = 0;
                        this.state.currentBet = 0;
                        this.state.minRaise = MIN_RAISE;
                        this.state.phase = 'showdown';
                        this.state.currentTurn = 'none';
                        render.debouncedUpdateGameDisplay();
                    }
                    this.verifyChipTotal();
                    return;
                }

                if (this.state.currentTurn === 'none' || (this.allBetsEqual() && [...this.state.playersInRound].every(p => this.getPlayer(p).hasActed || this.state.allInPlayers.has(p) || this.state.foldedPlayers.has(p))) {
                    this.state.players.forEach(p => {
                        p.betThisRound = 0;
                        p.hasActed = false;
                    });
                    this.state.currentBet = 0;
                    this.state.minRaise = MIN_RAISE;

                    if (this.state.phase === 'preflop') {
                        this.state.phase = 'flop';
                        this.ensureDeckSize(3);
                        this.state.communityCards = this.state.deck.splice(0, 3);
                        render.logAction('Flop dealt.');
                        this.state.currentTurn = this.getNextTurnFromDealer();
                    } else if (this.state.phase === 'flop') {
                        this.state.phase = 'turn';
                        this.ensureDeckSize(1);
                        this.state.communityCards.push(this.state.deck.shift());
                        render.logAction('Turn dealt.');
                        this.state.currentTurn = this.getNextTurnFromDealer();
                    } else if (this.state.phase === 'turn') {
                        this.state.phase = 'river';
                        this.ensureDeckSize(1);
                        this.state.communityCards.push(this.state.deck.shift());
                        render.logAction('River dealt.');
                        this.state.currentTurn = this.getNextTurnFromDealer();
                    } else if (this.state.phase === 'river') {
                        this.state.phase = 'showdown';
                        this.createSidePots();
                        this.determineWinner();
                        this.state.currentTurn = 'none';
                        render.debouncedUpdateGameDisplay();
                        this.verifyChipTotal();
                        return;
                    }
                    render.debouncedUpdateGameDisplay();
                } else {
                    this.state.currentTurn = this.getNextTurn();
                    render.debouncedUpdateGameDisplay();
                }

                this.verifyChipTotal();

                if (this.state.currentTurn !== 'player' && this.state.currentTurn !== 'none') {
                    setTimeout(() => ai.makeMove(this.state.currentTurn), 1000);
                }
            },

            determineWinner() {
                const eligiblePlayers = this.state.players.filter(p =>
                    (this.state.playersInRound.has(p.id) || this.state.allInPlayers.has(p.id)) &&
                    !this.state.foldedPlayers.has(p.id)
                );

                if (eligiblePlayers.length === 0) {
                    render.logAction('No eligible players for showdown.');
                    return;
                }

                const hands = eligiblePlayers.map(player => ({
                    id: player.id,
                    hand: this.evaluateHand([...player.cards, ...this.state.communityCards]),
                    name: this.getPlayerName(player.id)
                }));

                hands.forEach(player => {
                    if (this.state.phase === 'showdown' && !this.state.foldedPlayers.has(player.id)) {
                        render.logAction(`${player.name} shows ${this.getHandDescription(player.hand)}.`);
                    }
                });

                this.state.sidePots.forEach(pot => {
                    const eligibleForPot = hands.filter(h => pot.eligiblePlayers.includes(h.id));
                    if (eligibleForPot.length === 0) return;

                    eligibleForPot.sort((a, b) => {
                        if (a.hand.score !== b.hand.score) return b.hand.score - a.hand.score;
                        if (a.hand.high !== b.hand.high) return b.hand.high - a.hand.high;
                        for (let i = 0; i < Math.min(a.hand.tiebreakers.length, b.hand.tiebreakers.length); i++) {
                            if (a.hand.tiebreakers[i] !== b.hand.tiebreakers[i]) return b.hand.tiebreakers[i] - a.hand.tiebreakers[i];
                        }
                        return 0;
                    });

                    const highestScore = eligibleForPot[0].hand.score;
                    const highestHigh = eligibleForPot[0].hand.high;
                    const highestTiebreakers = eligibleForPot[0].hand.tiebreakers;
                    const winners = eligibleForPot.filter(h =>
                        h.hand.score === highestScore &&
                        h.hand.high === highestHigh &&
                        h.hand.tiebreakers.every((t, i) => t === highestTiebreakers[i])
                    );

                    const potShare = Math.floor(pot.amount / winners.length);
                    let remainingChips = pot.amount % winners.length;
                    winners.forEach(winner => {
                        const player = this.getPlayer(winner.id);
                        const share = potShare + (remainingChips > 0 ? 1 : 0);
                        player.chips += share;
                        player.wins++;
                        render.logAction(`${winner.name} wins ${share} chips with ${this.getHandDescription(winner.hand)}.`);
                        if (remainingChips > 0) remainingChips--;
                    });
                });

                this.state.pot = 0;
                this.state.currentBet = 0;
                this.state.minRaise = MIN_RAISE;
                this.logChipCounts();
                this.verifyChipTotal();
                render.debouncedUpdateGameDisplay();
            },

            resetRound() {
                this.state.deck = this.shuffle([...DECK]);
                this.state.communityCards = [];
                this.state.pot = 0;
                this.state.currentBet = 0;
                this.state.minRaise = MIN_RAISE;
                this.state.phase = 'preflop';
                this.state.playersInRound = new Set(ALL_PLAYERS.filter(p => this.getChips(p) > 0));
                this.state.foldedPlayers.clear();
                this.state.allInPlayers.clear();
                this.state.currentTurn = 'none';
                this.state.sidePots = [];
                this.state.players.forEach(p => {
                    p.cards = [];
                    p.betThisRound = 0;
                    p.totalBet = 0;
                    p.hasActed = false;
                });

                if (!this.state.isFirstGame) {
                    const dealerIndex = ALL_PLAYERS.indexOf(this.state.dealer);
                    this.state.dealer = ALL_PLAYERS[(dealerIndex + 1) % 4];
                }
                const dealerIndex = ALL_PLAYERS.indexOf(this.state.dealer);
                const smallBlindIndex = (dealerIndex + 1) % 4;
                const bigBlindIndex = (dealerIndex + 2) % 4;
                this.state.smallBlindPlayer = ALL_PLAYERS[smallBlindIndex];
                this.state.bigBlindPlayer = ALL_PLAYERS[bigBlindIndex];

                this.ensureDeckSize(8);
                this.state.playersInRound.forEach(p => {
                    const player = this.getPlayer(p);
                    player.cards = this.state.deck.splice(0, 2);
                });

                if (this.getChips(this.state.smallBlindPlayer) > 0) {
                    this.makeBet(this.state.smallBlindPlayer, BLINDS.small, false, true);
                } else {
                    this.state.playersInRound.delete(this.state.smallBlindPlayer);
                    this.state.foldedPlayers.add(this.state.smallBlindPlayer);
                    render.logAction(`${this.getPlayerName(this.state.smallBlindPlayer)} skipped small blind (no chips).`);
                }

                if (this.getChips(this.state.bigBlindPlayer) > 0) {
                    this.makeBet(this.state.bigBlindPlayer, BLINDS.big, true, true);
                    this.state.currentBet = BLINDS.big;
                } else {
                    this.state.playersInRound.delete(this.state.bigBlindPlayer);
                    this.state.foldedPlayers.add(this.state.bigBlindPlayer);
                    render.logAction(`${this.getPlayerName(this.state.bigBlindPlayer)} skipped big blind (no chips).`);
                }

                if (this.checkGameOver()) return;

                this.state.currentTurn = ALL_PLAYERS[(bigBlindIndex + 1) % 4];
                if (!this.state.playersInRound.has(this.state.currentTurn) || this.state.foldedPlayers.has(this.state.currentTurn) || this.state.allInPlayers.has(this.state.currentTurn)) {
                    this.state.currentTurn = this.getNextTurnFromBigBlind(this.state.bigBlindPlayer);
                }

                render.logAction('--- New Game Started ---');
                this.logChipCounts();
                this.state.isFirstGame = false;
                render.debouncedUpdateGameDisplay();

                if (this.state.currentTurn !== 'player' && this.state.currentTurn !== 'none') {
                    setTimeout(() => ai.makeMove(this.state.currentTurn), 1000);
                }
            },

            resetGame() {
                this.state = {
                    ...this.state,
                    deck: this.shuffle([...DECK]),
                    communityCards: [],
                    pot: 0,
                    currentBet: 0,
                    minRaise: MIN_RAISE,
                    phase: 'preflop',
                    playersInRound: new Set(ALL_PLAYERS),
                    foldedPlayers: new Set(),
                    allInPlayers: new Set(),
                    currentTurn: 'none',
                    dealer: 'player3',
                    smallBlindPlayer: null,
                    bigBlindPlayer: null,
                    actionLog: [],
                    isFirstGame: true,
                    sidePots: [],
                    players: ALL_PLAYERS.map(id => ({
                        id,
                        chips: 1000,
                        cards: [],
                        betThisRound: 0,
                        totalBet: 0,
                        wins: 0,
                        folds: 0,
                        hasActed: false
                    }))
                };
                render.logAction('--- Game Reset ---');
                render.lastWinnerText = '';
                render.debouncedUpdateGameDisplay();
            }
        }; // End of gameLogic object

        const ai = {
            evaluatePreflopHand(cards) {
                if (cards.length !== 2) return 0;
                const [card1, card2] = cards;
                const rank1 = gameLogic.rankValues.get(card1.rank);
                const rank2 = gameLogic.rankValues.get(card2.rank);
                const isSuited = card1.suit === card2.suit;
                const isPair = rank1 === rank2;
                const highRank = Math.max(rank1, rank2);
                const lowRank = Math.min(rank1, rank2);
                const gap = Math.abs(rank1 - rank2);

                let strength = highRank / 12 * 0.4;
                if (isPair) {
                    strength = Math.max(strength, 0.5 + (highRank / 12) * 0.3);
                }
                if (isSuited) {
                    strength += 0.1;
                }
                if (gap <= 4 && !isPair) {
                    strength += 0.1 - gap * 0.02;
                }
                const positionIndex = ALL_PLAYERS.indexOf(gameLogic.state.currentTurn);
                const dealerIndex = ALL_PLAYERS.indexOf(gameLogic.state.dealer);
                const relativePosition = (positionIndex - dealerIndex + 4) % 4;
                const positionFactor = relativePosition / 3 * 0.1;
                const stackToPot = gameLogic.getChips(gameLogic.state.currentTurn) / (gameLogic.state.pot + 1);
                return Math.min(1, strength + positionFactor + (stackToPot > 10 ? 0.1 : 0));
            },

            evaluateHandStrength(hand) {
                return (hand.score / 8) * 0.7 + (hand.high / 12) * 0.2 + (hand.tiebreakers.reduce((sum, t) => sum + t, 0) / (12 * hand.tiebreakers.length)) * 0.1;
            },

            makeMove(id) {
                if (gameLogic.state.currentTurn !== id || gameLogic.state.phase === 'showdown' || gameLogic.state.allInPlayers.has(id)) return;
                const player = gameLogic.getPlayer(id);
                if (!player) return;

                const cards = gameLogic.state.phase === 'preflop' ? player.cards : [...player.cards, ...gameLogic.state.communityCards];
                const handStrength = gameLogic.state.phase === 'preflop' ? this.evaluatePreflopHand(cards) : this.evaluateHandStrength(gameLogic.evaluateHand(cards));
                const toCall = gameLogic.state.currentBet - player.betThisRound;
                const potOdds = toCall > 0 ? toCall / (gameLogic.state.pot + toCall) : 0;
                const bluffChance = ALL_PLAYERS.indexOf(id) > ALL_PLAYERS.indexOf(gameLogic.state.dealer) ? 0.1 : 0;

                console.log(`AI move for ${gameLogic.getPlayerName(id)}: handStrength=${handStrength.toFixed(2)}, potOdds=${potOdds.toFixed(2)}, toCall=${toCall}`);

                const minRaise = Math.max(gameLogic.state.minRaise, gameLogic.state.currentBet + BLINDS.big);
                const maxRaise = player.chips + player.betThisRound;

                if (handStrength >= 0.7 && player.chips >= minRaise && (Math.random() < 0.5 || Math.random() < bluffChance)) {
                    const raiseAmount = Math.min(maxRaise, Math.max(minRaise, Math.floor((gameLogic.state.pot * (0.8 + Math.random() * 0.4)) / 25) * 25));
                    if (gameLogic.makeBet(id, raiseAmount, true)) {
                        render.logAction(`${gameLogic.getPlayerName(id)} raised to ${raiseAmount}.`);
                        gameLogic.state.currentTurn = gameLogic.getNextTurn();
                        render.debouncedUpdateGameDisplay();
                        gameLogic.checkRound();
                    }
                } else if (toCall === 0 && handStrength >= 0.3) {
                    render.logAction(`${gameLogic.getPlayerName(id)} checked.`);
                    gameLogic.getPlayer(id).hasActed = true;
                    gameLogic.state.currentTurn = gameLogic.getNextTurn();
                    render.debouncedUpdateGameDisplay();
                    gameLogic.checkRound();
                } else if (toCall > 0 && handStrength > potOdds && player.chips >= toCall) {
                    if (gameLogic.makeBet(id, toCall)) {
                        gameLogic.state.currentTurn = gameLogic.getNextTurn();
                        render.debouncedUpdateGameDisplay();
                        gameLogic.checkRound();
                    }
                } else {
                    gameLogic.state.playersInRound.delete(id);
                    gameLogic.state.foldedPlayers.add(id);
                    player.folds++;
                    render.logAction(`${gameLogic.getPlayerName(id)} folded.`);
                    gameLogic.state.currentTurn = gameLogic.getNextTurn();
                    gameLogic.checkRound();
                }
            }
        };

        function init() {
            render.initDOM();
            render.DOM.startButton.addEventListener('click', () => gameLogic.resetRound());
            render.DOM.continueButton.addEventListener('click', () => gameLogic.resetRound());
            render.DOM.foldButton.addEventListener('click', () => gameLogic.fold());
            render.DOM.checkCallButton.addEventListener('click', () => gameLogic.checkOrCall());
            render.DOM.raiseButton.addEventListener('click', () => gameLogic.raise());
            render.DOM.raiseAmount.addEventListener('input', () => render.validateRaiseAmount());
            render.DOM.resetGameButton.addEventListener('click', () => gameLogic.resetGame());
            render.DOM.logToggle.addEventListener('click', () => {
                render.DOM.actionLog.classList.toggle('hidden');
                render.DOM.logToggle.textContent = render.DOM.actionLog.classList.contains('hidden') ? 'Show Log' : 'Hide Log';
            });
            document.addEventListener('keydown', e => {
                if (e.key.toLowerCase() === 's') render.DOM.startButton.click();
                if (e.key.toLowerCase() === 'c') render.DOM.continueButton.click();
                if (e.key.toLowerCase() === 'f') render.DOM.foldButton.click();
                if (e.key.toLowerCase() === 'k') render.DOM.checkCallButton.click();
                if (e.key.toLowerCase() === 'r') render.DOM.raiseButton.click();
                if (e.key.toLowerCase() === 'q') render.DOM.resetGameButton.click();
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth * 0.9, window.innerWidth * 0.9 * 0.6);
                render.updateCardPositions();
                render.updateTextPositions();
                render.updateGameDisplay();
            });
            render.updateGameDisplay();
        }

        init();
    </script>
</body>
</html>